<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.1.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>Java基础 - ycNote</title>

  
    <meta name="description" content="JAVA基础 第1章 JAVA语言概述 第2章 基本语法 第3章 数组 第4&#x2F;5&#x2F;6章 面向对象 类和类的成员：属性、方法、构造器、代码块和内部类 封装、继承和多态 关键字及其使用  Day 8 （P198-P218）1、形参与实参形参：方法定义时，声明的小括号内的参数 实参：方法调用时，实际传递给形参的数据 2、值传递机制方法的形参传递机制：值传递 如果参数是基本数据类型，此">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://c508.github.io/2022/03/27/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="ycNote">
<meta property="og:description" content="JAVA基础 第1章 JAVA语言概述 第2章 基本语法 第3章 数组 第4&#x2F;5&#x2F;6章 面向对象 类和类的成员：属性、方法、构造器、代码块和内部类 封装、继承和多态 关键字及其使用  Day 8 （P198-P218）1、形参与实参形参：方法定义时，声明的小括号内的参数 实参：方法调用时，实际传递给形参的数据 2、值传递机制方法的形参传递机制：值传递 如果参数是基本数据类型，此">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/86187/Desktop/MD笔记/JAVA基础/变量.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211112145641093.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211112170536925.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211119210908171.png">
<meta property="og:image" content="c:/Users/86187/Desktop/MD笔记/JAVA基础/图片1.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211126110036164.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211201152708151.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211204204821092.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211208142527668.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211208142444965.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211210142652719.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211211125620004.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211211154252672.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211211165932089.png">
<meta property="og:image" content="c:/Users/86187/AppData/Roaming/Typora/typora-user-images/image-20211212162455735.png">
<meta property="article:published_time" content="2022-03-27T12:23:24.000Z">
<meta property="article:modified_time" content="2022-03-27T12:25:18.048Z">
<meta property="article:author" content="mikang">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/86187/Desktop/MD笔记/JAVA基础/变量.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">ycNote</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">TOC</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4-x2F-5-x2F-6%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">第4&#x2F;5&#x2F;6章 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-8-%EF%BC%88P198-P218%EF%BC%89"><span class="toc-text">Day 8 （P198-P218）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82"><span class="toc-text">1、形参与实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-text">2、值传递机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%B1%9E%E6%80%A7%EF%BC%88%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%89vs-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">3、属性（成员变量）vs 局部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-9-%EF%BC%88P219-P241%EF%BC%89"><span class="toc-text">Day 9 （P219-P241）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="toc-text">1、封装与隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2、权限修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">3、构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81UML%E7%B1%BB%E5%9B%BE"><span class="toc-text">4、UML类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">5、this关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81package%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">6、package关键字的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">7、MVC设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81import%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">8、import关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-10-P242-P264"><span class="toc-text">Day 10 (P242-P264)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%A1%B9%E7%9B%AE2"><span class="toc-text">1、项目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-text">2、继承性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-11-%EF%BC%88P265-P284%EF%BC%89"><span class="toc-text">Day 11 （P265-P284）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%88overwrite%EF%BC%89"><span class="toc-text">1、方法重写（overwrite）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2、super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">3、多态性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-12-%EF%BC%88P285-P311%EF%BC%89"><span class="toc-text">Day 12 （P285-P311）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-text">1、向下转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2、instanceof关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Object%E7%B1%BB"><span class="toc-text">3、Object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81-x3D-x3D"><span class="toc-text">4、&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81equals%EF%BC%88%EF%BC%89"><span class="toc-text">5、equals（）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81toString"><span class="toc-text">6、toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">7、单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">8、包装类的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-13-P312-P338"><span class="toc-text">Day 13 (P312-P338)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1、static关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">2、内存结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">3、单例设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">6、final关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-14%EF%BC%88P339-P366%EF%BC%89"><span class="toc-text">Day 14（P339-P366）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81abstract"><span class="toc-text">1、abstract</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#abstract%E4%BB%8B%E7%BB%8D"><span class="toc-text">abstract介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">抽象的应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">抽象类的匿名子类对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-text">接口介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%BA%94%E7%94%A8"><span class="toc-text">接口应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-text">接口笔试题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java8%E4%B8%AD%E6%8E%A5%E5%8F%A3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">java8中接口新特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">抽象类和接口的异同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">3、内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93"><span class="toc-text">4、关键字总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">第7章 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-15%EF%BC%88P367-P385%EF%BC%89"><span class="toc-text">Day 15（P367-P385）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1、异常概述与异常体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-text">2、常见异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81try-catch-finally"><span class="toc-text">3、try-catch-finally</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%9A%E6%8A%93%E6%8A%9B%E6%A8%A1%E5%9E%8B"><span class="toc-text">异常的处理：抓抛模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#try-catch-finally"><span class="toc-text">try-catch-finally</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81throws"><span class="toc-text">4、throws</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">方法重写的规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">开发中异常处理的选择</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9Athrow"><span class="toc-text">5、手动抛出异常：throw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">6、用户自定义异常类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">第8章 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-15-%EF%BC%88P406-P427%EF%BC%89"><span class="toc-text">Day 15 （P406-P427）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">1、程序、进程、线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">2、线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%BA%8EThread%E7%B1%BB"><span class="toc-text">方式一：继承于Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">方式二：实现Runnable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">两种方式的对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Day-16%EF%BC%88P428-P447%EF%BC%89"><span class="toc-text">Day 16（P428-P447）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3、线程的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">4、线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">方式一：同步代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">方式二：同步方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">同步方法总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">线程安全的单例模式：懒汉式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lock%EF%BC%88%E9%94%81%EF%BC%89"><span class="toc-text">Lock（锁）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">5、线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98-%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">经典例题:生产者&#x2F;消费者问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">6、JDK5.0新增线程创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现Callable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">使用线程池</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">7、总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-JAVA%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">第9章 JAVA常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-text">1、字符串相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">String类及常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81JDK8%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-text">2、JDK8之前的日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#System%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">System静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-text">Date类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-text">Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleDateFormat%E7%B1%BB"><span class="toc-text">SimpleDateFormat类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81JDK8%E4%B8%AD%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-text">3、JDK8中新日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDate-x2F-LocalTime-x2F-LocalDateTime"><span class="toc-text">LocalDate&#x2F;LocalTime&#x2F;LocalDateTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instant"><span class="toc-text">Instant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DateTimeFormatter"><span class="toc-text">DateTimeFormatter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB"><span class="toc-text">其他类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81JAVA%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">4、JAVA比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparable%E6%8E%A5%E5%8F%A3"><span class="toc-text">Comparable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparator%E6%8E%A5%E5%8F%A3"><span class="toc-text">Comparator接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81System%E7%B1%BB"><span class="toc-text">5、System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Math%E7%B1%BB"><span class="toc-text">6、Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81BigInteger%E4%B8%8EBigDecimal"><span class="toc-text">7、BigInteger与BigDecimal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB-amp-%E6%B3%A8%E8%A7%A3"><span class="toc-text">第10章 枚举类&amp;注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">1、如何自定义枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">2、如何使用关键字enum定义枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Enum%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">3、Enum类的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">4、实现接口的枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-JAVA%E9%9B%86%E5%90%88"><span class="toc-text">第11章 JAVA集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81JAVA%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1、JAVA集合框架概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Collection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-text">2、Collection接口方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">3、Iterator迭代器接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B8%80%EF%BC%9AList"><span class="toc-text">4、Collection子接口一：List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">ArrayList源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">LinkedList源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%BA%8C%EF%BC%9ASet"><span class="toc-text">5、Collection子接口二：Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashSet"><span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E4%B9%A0%E9%A2%98"><span class="toc-text">set习题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Map%E6%8E%A5%E5%8F%A3"><span class="toc-text">6、Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="toc-text">Map实现类结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E7%BB%93%E6%9E%84"><span class="toc-text">Map结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-JDK7"><span class="toc-text">HashMap JDK7</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-JDK8"><span class="toc-text">HashMap JDK8</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Map中定义的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-text">Properties</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7、Collections工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-text">第12章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">1、为什么要有泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-text">2、在集合中使用泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-text">3、自定义泛型结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">4、泛型在继承上的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5、通配符的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0IO%E6%B5%81"><span class="toc-text">第13章IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1、File类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2、IO流原理及流的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%8A%82%E7%82%B9%E6%B5%81%EF%BC%88%E6%88%96%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%89"><span class="toc-text">3、节点流（或文件流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5"><span class="toc-text">读入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%87%BA"><span class="toc-text">写出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">4、缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">5、转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">6、标准输入、输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">7、打印流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">8、数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-text">9、对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serializable%E6%8E%A5%E5%8F%A3"><span class="toc-text">Serializable接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">10、随机存取文件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81NIO-2%E4%B8%ADPath%E3%80%81Paths%E3%80%81Files%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">11、NIO.2中Path、Paths、Files类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">第14章 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A0%E6%A6%82%E8%BF%B0"><span class="toc-text">1、网络通信要素概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A01%EF%BC%9AIP%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">2、通信要素1：IP和端口号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A02%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-text">3、通信要素2：网络协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">4、TCP网络编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">5、UDP网络编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81URL%E7%BC%96%E7%A8%8B"><span class="toc-text">6、URL编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">第15章 JAVA反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1、Java反射机制概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B"><span class="toc-text">2、理解Class类并获取Class实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">3、类的加载与ClassLoader的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">4、创建运行时类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-text">5、获取运行时类的完整结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="toc-text">6、调用运行时类的指定结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">7、反射的应用：动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0JAVA8-%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">第16章JAVA8 的其他新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%8B%E5%89%8D%E6%8F%90%E5%88%B0%E7%9A%84JAVA8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-text">之前提到的JAVA8新特性：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java8%E4%B8%AD%E6%8E%A5%E5%8F%A3%E6%96%B0%E7%89%B9%E6%80%A7-1"><span class="toc-text">java8中接口新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK8%E4%B8%AD%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-text">JDK8中新日期时间API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK8%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">JDK8中注解的新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-JDK8-1"><span class="toc-text">HashMap JDK8</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">其他新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1、Lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%EF%BC%88Functional%EF%BC%89%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、函数式（Functional）接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">3、方法引用与构造器引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BC%BA%E5%A4%A7%E7%9A%84Stream-API"><span class="toc-text">4、强大的Stream API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Optional%E7%B1%BB"><span class="toc-text">5、Optional类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-JAVA9-amp-JAVA10-amp-JAVA11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">第17章 JAVA9 &amp; JAVA10 &amp; JAVA11新特性</span></a></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2022-03-27T12:23:24.000Z">2022-03-27</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>Java基础</span></h1>
<p>JAVA基础</p>
<p>第1章 JAVA语言概述</p>
<p>第2章 基本语法</p>
<p>第3章 数组</p>
<h2 id="第4-x2F-5-x2F-6章-面向对象"><a href="#第4-x2F-5-x2F-6章-面向对象" class="headerlink" title="第4&#x2F;5&#x2F;6章 面向对象"></a>第4&#x2F;5&#x2F;6章 面向对象</h2><ol>
<li>类和类的成员：属性、方法、构造器、代码块和内部类</li>
<li>封装、继承和多态</li>
<li>关键字及其使用</li>
</ol>
<h3 id="Day-8-（P198-P218）"><a href="#Day-8-（P198-P218）" class="headerlink" title="Day 8 （P198-P218）"></a>Day 8 （P198-P218）</h3><h4 id="1、形参与实参"><a href="#1、形参与实参" class="headerlink" title="1、形参与实参"></a>1、形参与实参</h4><p>形参：方法定义时，声明的小括号内的参数</p>
<p>实参：方法调用时，实际传递给形参的数据</p>
<h4 id="2、值传递机制"><a href="#2、值传递机制" class="headerlink" title="2、值传递机制"></a>2、值传递机制</h4><p>方法的形参传递机制：值传递</p>
<p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</p>
<p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值</p>
<h4 id="3、属性（成员变量）vs-局部变量"><a href="#3、属性（成员变量）vs-局部变量" class="headerlink" title="3、属性（成员变量）vs 局部变量"></a>3、属性（成员变量）vs 局部变量</h4><p>相同点：</p>
<p>​    1、定义变量的格式：数据类型 变量名&#x3D;变量值</p>
<p>​    2、先声明后使用</p>
<p>​    3、变量都有其作用域</p>
<p>不同点：</p>
<p>​    1、在类中声明的位置不同，属性直接定义在类的{}内，局部变量声明在方法内，方法形参，代码块内，构造器         形参、构造器内部的变量</p>
<p>​    2、权限修饰符：</p>
<p>​        属性：可以在声明属性时，指明其权限，使用权限修饰符</p>
<p>​        常用的权限修饰符：private、public、缺省、protected</p>
<p>​        局部变量：不可以使用权限修饰符</p>
<p>​    3、默认初始化值</p>
<p>​        属性：类的属性，根据其类型都有默认初始化值</p>
<p>​                    整型（byte、short、int、long）:0</p>
<p>​                    浮点型（float、double）:0.0</p>
<p>​                    字符型（char）:0（或’\u0000’）</p>
<p>​                    布尔型（boolean）:false</p>
<p>​                    引用数据类型（<strong>字符串</strong>、类、数组、接口）:null</p>
<p>​        局部变量：没有默认初始化，在调用局部变量之前一定要显式化赋值</p>
<p>​                    特别的，形参在调用时赋值即可</p>
<p>​    4、在内存中加载的位置</p>
<p>​        属性：加载到堆空间中</p>
<p>​        局部变量：加载到栈空间</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\Desktop\MD笔记\JAVA基础\变量.png"></p>
<h3 id="Day-9-（P219-P241）"><a href="#Day-9-（P219-P241）" class="headerlink" title="Day 9 （P219-P241）"></a>Day 9 （P219-P241）</h3><h4 id="1、封装与隐藏"><a href="#1、封装与隐藏" class="headerlink" title="1、封装与隐藏"></a>1、封装与隐藏</h4><p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p>
<p>低耦合：仅对外暴露少量的方法用于使用</p>
<h4 id="2、权限修饰符"><a href="#2、权限修饰符" class="headerlink" title="2、权限修饰符"></a>2、权限修饰符</h4><p>​    1、四种权限（从小到大）：private，缺省(default)，protected，public</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>​    2、4种权限可以用来修饰类及内部类的内部结构：属性、方法、构造器、内部类</p>
<p>​          修饰类只能用缺省、public</p>
<p>​          总结封装性：JAVA提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p>
<h4 id="3、构造器"><a href="#3、构造器" class="headerlink" title="3、构造器"></a>3、构造器</h4><p>​    1、构造器的作用：创建对象、初始化对象的属性</p>
<p>​          如果没有显式的定义类的构造器，则系统默认提供一个空参的构造器</p>
<p>​          一个类中定义的多个构造器彼此构成重载</p>
<p>​    2、属性赋值的选后顺序：①默认初始化 ②显式初始化 ③构造器中赋值 ④通过对象.方法或对象.属性赋值</p>
<p>​    3、只要造对象，就一定会使用构造器，这句话任何时候都是对的</p>
<h4 id="4、UML类图"><a href="#4、UML类图" class="headerlink" title="4、UML类图"></a>4、UML类图<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211112145641093.png" alt="image-20211112145641093"></h4><h4 id="5、this关键字"><a href="#5、this关键字" class="headerlink" title="5、this关键字"></a>5、this关键字</h4><p>​    1、方法的形参和类的属性同名时，必须显式使用this.变量的方式，表明此变量是属性，而非形参</p>
<p>​    2、this可以调用属性、方法和构造器</p>
<p>​    3、可以显式使用”this(形参列表)”方式，调用本类中指定的其他构造器</p>
<p>​          “this(形参列表)”必须声明在当前构造器的首行</p>
<p>​          构造器中不能使用 “this(形参列表)”的方式调用自己</p>
<p>​          构造器内部最多只能声明一个”this(形参列表)”调用其他构造器</p>
<h4 id="6、package关键字的使用"><a href="#6、package关键字的使用" class="headerlink" title="6、package关键字的使用"></a>6、package关键字的使用</h4><p>​    1、使用package声明类或者接口所属的包，声明在源文件的首行</p>
<p>​    2、每“.”一次，就代表一层文件目录</p>
<p>​    3、同一个包下，不能命名同名的接口和类，不同包下可以声明同名的接口和类</p>
<h4 id="7、MVC设计模式"><a href="#7、MVC设计模式" class="headerlink" title="7、MVC设计模式"></a>7、MVC设计模式</h4><p>将程序分成三个层次：视图模型层（view）、控制器层（controller）与数据模型层（model）<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211112170536925.png" alt="image-20211112170536925"></p>
<h4 id="8、import关键字"><a href="#8、import关键字" class="headerlink" title="8、import关键字"></a>8、import关键字</h4><p>​    1、在源文件中使用import导入指定包下的类和接口</p>
<p>​    2、如果使用的类或者接口时java.lang包下定义的，则可以省略import结构</p>
<p>​          如果使用的类或者接口是本包下定义的，则可以省略import结构</p>
<p>​    3、如果在源文件中使用了不同包下的同名类，则必须至少有一个类需要以全类名的方式显示</p>
<p>​    4、使用“xxx.*”的方式可以调用包中的所有结构，但如果是子包，仍需要显式调用（我的理解就是没有子包，都是并列的包）</p>
<p>​    5、import static：导入类或接口中的静态结构（意思就是导入属性或者方法），单import是导入类或接口</p>
<h3 id="Day-10-P242-P264"><a href="#Day-10-P242-P264" class="headerlink" title="Day 10 (P242-P264)"></a>Day 10 (P242-P264)</h3><h4 id="1、项目2"><a href="#1、项目2" class="headerlink" title="1、项目2"></a>1、项目2</h4><p>​        1、动态数组，大小随时改变的写法   </p>
<p>​        2、删除数组中的元素，后面的元素要覆盖前面的，不能直接指空</p>
<h4 id="2、继承性"><a href="#2、继承性" class="headerlink" title="2、继承性"></a>2、继承性</h4><p>1、继承性的优点：</p>
<p>​    ①减少代码冗余，提高代码复用性</p>
<p>​    ②便于功能的扩展</p>
<p>2、继承的格式：classA extends classB{}</p>
<p>​    A：子类、派生类、subclass</p>
<p>​    B：父类、基类、超类、superclass</p>
<p>​    体现：一旦子类继承父类之后，子类就获取了父类中声明的属性和方法。</p>
<p>​    特别的，父类中声明为private的属性或者方法，仍然认为获取了父类中私有的结构，只是因为封装性的影响，子类不能直接调用。子类继承父类之后，可以声明自己持有的属性或方法实现功能的扩展。</p>
<p>3、JAVA中关于继承的规定    </p>
<p>​    ①支持单继承和多层继承，不允许多重继承</p>
<p>​        一个子类只能有一个父类，一个父类可以派生多个子类</p>
<p>​    ②直接父类和间接父类</p>
<p>​    ③所有类都直接或间接继承于Object类</p>
<h3 id="Day-11-（P265-P284）"><a href="#Day-11-（P265-P284）" class="headerlink" title="Day 11 （P265-P284）"></a>Day 11 （P265-P284）</h3><h4 id="1、方法重写（overwrite）"><a href="#1、方法重写（overwrite）" class="headerlink" title="1、方法重写（overwrite）"></a>1、方法重写（overwrite）</h4><p>​    1、重写：子类继承父类以后，可以对父类中同名参数的方法进行覆盖操作</p>
<p>​    2、重写之后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</p>
<p>​    3、重写的规定：</p>
<p>​        方法的声明：权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型{ 方法体 }</p>
<p>​        子类中叫<strong>重写</strong>的方法，父类中叫<strong>被重写</strong>的方法</p>
<p>​        ①子类重写的方法的方法名和形参列表与父类被重写的方法名和形参列表相同</p>
<p>​        ②子类重写的方法的权限修饰符不小于父类被重写方法的权限修饰符</p>
<p>​            特殊情况：子类不能重写父类中声明为private权限的方法</p>
<p>​        ③返回值类型：</p>
<p>​            父类被重写的方法的返回值是void：子类重写的方法只能是void</p>
<p>​            父类被重写的方法的返回值是引用类型：子类重写的方法只能和父类相同或者为其子类</p>
<p>​            父类被重写的方法的返回值是基本类型：子类重写的方法只能是相同的基本类型</p>
<p>​        ④子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<p>​        ⑤必须是非static        </p>
<h4 id="2、super关键字"><a href="#2、super关键字" class="headerlink" title="2、super关键字"></a>2、super关键字</h4><p>​    1、super可以用来调用属性、方法和构造器。</p>
<p>​    2、当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性则必须显式使用super.属性。</p>
<p>​          当子类重写了父类中的方法之后，要在子类中调用父类中被重写的方法则必须显式使用super.属性。</p>
<p>​    3、super调用构造器</p>
<p>​          可以在子类中使用 super（形参列表）的方式调用父类中声明的指定的构造器，必须声明在首行</p>
<p>​          在类的构造器中 this( 形参列表 )和super（形参列表）只能二选一，在构造器没有显式声明时，默认调用父类中的空参构造器</p>
<h4 id="3、多态性"><a href="#3、多态性" class="headerlink" title="3、多态性"></a>3、多态性</h4><p>​    1、父类的引用指向子类的对象——对象的多态性</p>
<p>​    2、多态的使用：虚拟方法的调用</p>
<p>​          有了对象的多态性之后，在编译期只能调用父类中声明的方法，编译期实际执行的是子类重写父类的方法</p>
<p>​          <strong>编译看左边，运行看右边</strong></p>
<p>​    3、多态性使用前提：①有类的继承关系 ②要有方法的重写</p>
<p>​    4、对象的多态性只适用于方法不适用于属性（还是父类的属性）</p>
<p>​    5、多态性是一个运行时行为，要到运行的时候才知道具体是哪一个，而重载是编译时行为，编译的时候就知道具体是哪一个</p>
<h3 id="Day-12-（P285-P311）"><a href="#Day-12-（P285-P311）" class="headerlink" title="Day 12 （P285-P311）"></a>Day 12 （P285-P311）</h3><h4 id="1、向下转型"><a href="#1、向下转型" class="headerlink" title="1、向下转型"></a>1、向下转型</h4><p>​    1、有了对象的多态性之后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时只能使用父类中声明的属性和方法。使用强制类型转换符之后就可以使用子类的属性和方法，即向下转型。</p>
<p>​    2、自动类型提升和强制类型转化（有可能会转不成功</p>
<p>​    3、P289：向下转型的几个问题</p>
<p>​    (那几个练习还蛮重要的感觉)</p>
<h4 id="2、instanceof关键字"><a href="#2、instanceof关键字" class="headerlink" title="2、instanceof关键字"></a>2、instanceof关键字</h4><p>​    1、a instanceof A:判断对象a是否为A的实例，如果是返回true。</p>
<p>​    2、使用情景：避免在向下转型时出现异常，先进行判断。</p>
<h4 id="3、Object类"><a href="#3、Object类" class="headerlink" title="3、Object类"></a>3、Object类</h4><p>​    1、Object类是所有类的根父类，类中的属性和方法具有通用性，Object类中只声明了一个空参构造器</p>
<p>​    2、Object类中的方法：</p>
<ul>
<li>clone()，克隆一个对象</li>
<li>funalize()，对象调用的用于垃圾回收的方法（不要主动调用，由垃圾回收器调用）</li>
<li><strong>equals()</strong> &#x2F; <strong>toString()</strong> &#x2F; getClass() &#x2F; hashCode() &#x2F; wait() &#x2F; notify() &#x2F; notifyAll()</li>
<li>数组也作为Object类的子类出现，可以调用Object类中声明的方法</li>
</ul>
<h4 id="4、-x3D-x3D"><a href="#4、-x3D-x3D" class="headerlink" title="4、&#x3D;&#x3D;"></a>4、&#x3D;&#x3D;</h4><p>​    1、可以使用在基本数据类型变量和引用数据类型变量中</p>
<p>​    2、基本数据类型变量：比较保存的数据（类型可以不同）</p>
<p>​          引用数据类型变量：比较地址值，即两个引用是否指向同一个对象实体</p>
<p>​    3、基本数据类型除了boolean以外都会有自动类型提升所以不用太关注类型，关注值。引用类型的话类型都不同地址必不可能相同</p>
<h4 id="5、equals（）"><a href="#5、equals（）" class="headerlink" title="5、equals（）"></a>5、equals（）</h4><p>​    1、基本数据类型不是类，无法调用equals（）方法，只适用于引用数据类型</p>
<p>​    2、Object类中equals()方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>==obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    说明Object类中equals()方法和&#x3D;&#x3D;相同，比较地址值，即两个引用是否指向同一个对象实体</p>
<p>​    3、String\Date\File\包装类都重写了Object类中的equals()方法，重写后比较的是属性是否相同（内容是否相同）</p>
<p>​    4、自定义的类如果使用equals()方法，也通常是比较实体内容，那就需要重写。重写的步骤：先&#x3D;&#x3D;判断一下，如果&#x3D;&#x3D;直接返回true，然后判断是否为同一类型，是的话向下转型然后比较需要的属性</p>
<p>​          系统可以自动生成equals()方法比较你需要的属性。</p>
<p>​    5、x.equals(null)永远都是false,比较的前提是类型相同</p>
<p>​    6、常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;BB&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;BB&quot;</span>;</span><br><span class="line">System.out.println(s1==s2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>两个对象都在常量池中，两个对象的地址一样</p>
<p>当 “&#x3D;&#x3D;”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。</p>
<h4 id="6、toString"><a href="#6、toString" class="headerlink" title="6、toString()"></a>6、toString()</h4><p>​    1、当我们输出一个对象的引用时，实际上是调用当前对象的toString()</p>
<p>​    2、Object类中toString()的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()+<span class="string">&quot;@&quot;</span>+Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：类名@地址值（JVM中的虚拟地址值）</p>
<p>​    3、String&#x2F;Date&#x2F;File&#x2F;包装类把toString()重写了，输出的是内容。自定义类也可以重写。</p>
<h4 id="7、单元测试"><a href="#7、单元测试" class="headerlink" title="7、单元测试"></a>7、单元测试</h4><p>（讲的是Eclipse的单元测试，要用的话就去找IDEA的）</p>
<h4 id="8、包装类的使用"><a href="#8、包装类的使用" class="headerlink" title="8、包装类的使用"></a>8、包装类的使用</h4><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<p>1、基本类型与包装类的转换</p>
<ul>
<li>基本数据类型–&gt;包装类：调用包装类的构造器</li>
<li>包装类–&gt;基本数据类型：调用xxxValue()</li>
</ul>
<p>2、JDK 5.0新特性：自动装箱和自动拆箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">Integer num1=num;<span class="comment">//自动装箱：基本数据类型---&gt;包装类</span></span><br><span class="line"><span class="type">int</span> num2=num1;<span class="comment">//自动拆箱：包装类---&gt;基本数据类型  </span></span><br></pre></td></tr></table></figure>

<p>3、基本数据类型、包装类—&gt;String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1:连接运算（其他基本类型都可以用这种方式）</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">String str=num+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//方式2：valueOf()</span></span><br><span class="line"><span class="type">float</span> f1=<span class="number">12.3f</span>;</span><br><span class="line">String str1=String.valueOf(f1);</span><br></pre></td></tr></table></figure>

<p>4、String—&gt;基本数据类型、包装类：调用包装类的parseXxx()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> num=Integer.parseInt(str);</span><br></pre></td></tr></table></figure>

<p>可能会报NumberFormatException，比如”true”要转int就是不可能的，就会报错<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211119210908171.png" alt="image-20211119210908171"></p>
<p>熟练掌握：<strong>自动装箱和拆箱，valueOf()，parseXxx()</strong></p>
<p>5、课后题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目1</span></span><br><span class="line">Object o1=<span class="literal">true</span>?<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>):<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.1</span>);</span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br><span class="line"><span class="comment">//三目运算符要求类型相同，int自动类型提升为double</span></span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)o2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> o2=<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o2);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    Integer i=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    Integer j=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    Integer m=<span class="number">1</span>;</span><br><span class="line">    Integer n=<span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    Integer x=<span class="number">128</span>;</span><br><span class="line">    Integer y=<span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①两个不同的对象</p>
<p>②Integer内部定义了IngeterCache()方法，其中定义了Ingeter[]，保存了-128<del>127的整数，如果给Ingeter赋值的范围在-128</del>127以内，可以直接使用数组中的元素，不用去new了，如此可以提高效率</p>
<p>③超过了缓存池的大小，所以是new了两个不同的对象</p>
<h3 id="Day-13-P312-P338"><a href="#Day-13-P312-P338" class="headerlink" title="Day 13 (P312-P338)"></a>Day 13 (P312-P338)</h3><h4 id="1、static关键字"><a href="#1、static关键字" class="headerlink" title="1、static关键字"></a>1、static关键字</h4><p>​    1、static可以用来修饰：属性、方法、代码块、内部类</p>
<p>​    2、static修饰属性：静态变量（类变量），非静态变量（实例变量)</p>
<ul>
<li><p>按是否有static修饰，属性又可分为静态属性和非静态属性</p>
</li>
<li><p>实例变量：创建了多个对象之后，每个对象独立拥有一套非静态属性，修改其中一个对象的非静态属性不会导致其他对象中同样的属性的修改</p>
</li>
<li><p>静态变量：多个对象共享同一个静态变量，当通过某一个对象修改静态变量时，其他对象的该变量也一起改变</p>
</li>
<li><p>静态变量随着类的加载而加载，早于对象的创建，可以通过“类.静态变量”的方式调用</p>
<p>由于类只会加载一次，静态变量在内存中也只有一份</p>
</li>
<li><p>静态属性举例：System.out，Math.PI</p>
</li>
</ul>
<p>​    3、static修饰方法：静态方法</p>
<p>​          ① 静态方法随着类的加载而加载，早于对象的创建，可以通过“类.静态方法”的方式调用</p>
<p>​          ② 静态方法中，只能调用静态的方法和属性</p>
<p>​               非静态方法中，既可以调用静态的属性和方法，也可以调用非静态的</p>
<p>​    4、在静态方法内，不能室友this、super关键字</p>
<p>​    5、在开发中，如何确定一个属性要声明为static？</p>
<p>​          属性可以被多个对象共享，不会因为对象的不同而不同</p>
<p>​    6、在开发中，如何确定一个方法要声明为static？</p>
<p>​         工具类中的方法，习惯上声明为static，比如Math\Arrays\Collections</p>
<p>​         操作静态属性的方法</p>
<p>​    7、使用举例</p>
<p>​         ①Math\Arrays\Collections等工具类</p>
<p>​         ②单例模式</p>
<h4 id="2、内存结构图"><a href="#2、内存结构图" class="headerlink" title="2、内存结构图"></a>2、内存结构图</h4><p>栈：局部变量</p>
<p>堆：new出来的结构，对象、数组</p>
<p>方法区：类的加载信息、静态域、常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String nation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Chinese.nation=<span class="string">&quot;中国&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    Chinese c1=<span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line">    c1.name=<span class="string">&quot;姚明&quot;</span>;</span><br><span class="line">    c1.age=<span class="number">40</span>;</span><br><span class="line">    </span><br><span class="line">    Chinese c2=<span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line">    c1.name=<span class="string">&quot;马龙&quot;</span>;</span><br><span class="line">    c1.age=<span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(c1.nation);<span class="comment">//中国</span></span><br><span class="line">    c1.nation=<span class="string">&quot;CHN&quot;</span>;</span><br><span class="line">    System.out.println(c2.nation);<span class="comment">//CHN</span></span><br><span class="line">    c2.nation=<span class="string">&quot;CHINA&quot;</span>;</span><br><span class="line">    System.out.println(c1.nation);<span class="comment">//CHINA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\Desktop\MD笔记\JAVA基础\图片1.png"></p>
<h4 id="3、单例设计模式"><a href="#3、单例设计模式" class="headerlink" title="3、单例设计模式"></a>3、单例设计模式</h4><ol>
<li><p>单例设计模式就是采取一定的方法保证整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>
</li>
<li><p>单例模式的优点：只生成一个实例，减少系统性能开销。使用例：getRuntime()</p>
</li>
<li><p>区分饿汉式和懒汉式：</p>
<p>饿汉式——缺点：先创建对象，对象加载时间过长；优点：线程安全</p>
<p>懒汉式——优点：延迟对象的创建；缺点：下述写法线程不安全</p>
<p><strong>面试让你写的话优先写饿汉式</strong></p>
</li>
<li><pre><code class="Java">public class SingletonTest&#123;
    public static void main(String[] args)&#123;
        
        Bank bank1=Bank.getInstance();
        Bank bank2=Bank.getInstance();
        System.out.println(bank1==bank2);//true
        
        
    &#125;
&#125;
//--------饿汉式单例模式
//为什么要用静态呢，要在外面调用getInstance()方法，如果没有static，就得先造一个Bank类的对象，但类的构造器是私有化的，造不了对象，想要直接调用类的方法，必须声明static，静态的方法中才能调用静态的属性，所以对象也必须是静态的
class Bank&#123;
    //1、私有化类的构造器
    private Bank()&#123;
        
    &#125;
    //2、内部创建类的对象
    private static Bank instance=new Bank();
    //3、提供公共的静态方法返回类的对象,可以在main方法中通过类名调用方法
    public static Bank getInstance()&#123;
        return instance;
    &#125;
&#125;
//--------懒汉式单例模式
class Order&#123;
    //1、私有化类的构造器
    private Order()&#123;
        
    &#125;
    //2、声明当前类的对象
    private static Order instance=null;
    //3、声明public、static的返回当前类的对象
    public static Order getInstance()&#123;
        if(instance==null)&#123;
            instance=new Order();
        &#125;
        return instance;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4、理解main方法</span><br><span class="line"></span><br><span class="line">1. main()方法是程序的入口</span><br><span class="line">2. main()方法也是一个普通的静态方法</span><br><span class="line">3. main()方法可以作为我们与控制台交互的方式</span><br><span class="line"></span><br><span class="line">#### 5、代码块</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Person&#123;</span><br><span class="line">    //属性</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    static String desc=&quot;我是一个人&quot;;</span><br><span class="line">    //构造器</span><br><span class="line">    public Person()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name,int age)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    //非静态代码块</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;block&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //静态代码块</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;static block&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //方法</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;吃饭&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;Person[name=&quot;+name+&quot;,age=&quot;+age+&quot;]&quot;;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>代码块用于初始化类和对象，如果有修饰的话只能用static，加上static为静态代码块，不加为非静态</p>
</li>
<li><p>静态代码块：</p>
<p>①内部可以有输出语句</p>
<p>②随着类的加载而执行，而且只执行一次</p>
<p>③如果一个类中使用了多个静态代码块，则按照声明的先后顺序执行</p>
<p>④静态代码块的执行优先于非静态代码块的执行</p>
<p>⑤只能调用静态的属性或方法</p>
</li>
<li><p>非静态代码块</p>
<p>①内部可以有输出语句</p>
<p>②随着对象的创建而执行，每创建一个对象就执行一次，可以在创建对象时对对象的属性进行初始化</p>
<p>③如果一个类中使用了多个非静态代码块，则按照声明的先后顺序执行</p>
<p>④可以调用静态和非静态的属性或方法</p>
</li>
<li><p>给属性赋值的顺序</p>
<p>①默认初始化</p>
<p>②显式初始化&#x2F;在代码块中赋值（看谁写在前面）</p>
<p>③构造器中初始化</p>
<p>④创建对象，通过对象.属性或者对象.方法赋值</p>
</li>
<li><p>代码块的练习值得看一看：P332</p>
</li>
</ol>
<h4 id="6、final关键字"><a href="#6、final关键字" class="headerlink" title="6、final关键字"></a>6、final关键字</h4><ol>
<li><p>final修饰类：此类不能被其他类所继承，比如：String、System、StringBuffer</p>
</li>
<li><p>final修饰方法：此方法不能再被重写，比如：Object类中的getClass()</p>
</li>
<li><p>static final用来修饰属性：全局常量</p>
</li>
<li><p>final修饰变量：此时的变量就称为是一个常量</p>
<p>final修饰属性：可以考虑赋值的位置：显式初始化，代码块中初始化、构造器中初始化</p>
<p>final修饰局部变量：尤其是用final修饰形参时，表明此形参是一个常量，当调用此方法时，给常量形参赋实参，一旦赋值就只能在方法体内使用此形参，但不能重新赋值</p>
</li>
</ol>
<h3 id="Day-14（P339-P366）"><a href="#Day-14（P339-P366）" class="headerlink" title="Day 14（P339-P366）"></a>Day 14（P339-P366）</h3><p>P340后面改单例模式的权限修饰符，private改public有必要听一下</p>
<h4 id="1、abstract"><a href="#1、abstract" class="headerlink" title="1、abstract"></a>1、abstract</h4><h5 id="abstract介绍"><a href="#abstract介绍" class="headerlink" title="abstract介绍"></a>abstract介绍</h5><ol>
<li><p>可以用于修饰：类（抽象类）、方法（抽象方法）</p>
</li>
<li><p>abstract修饰类：</p>
<p>①此类不能实例化（也就是不能创建这个类的对象</p>
<p>②虽然自己不能实例化，但是子类会调用父类的构造器，所以抽象类中一定有构造器</p>
</li>
<li><p>abstract修饰方法</p>
<p>① 抽象方法只有方法的声明没有方法体，所在的类一定是抽象类。因为如果类不是抽象的，那这个类就可以造对象，可以造对象就可以调用。反之抽象类中可以没有抽象方法。</p>
<p>② 若子类重写了子类重写了父类所有的抽象方法才能实例化，如果没有全部重写，那么子类也是抽象类，也需要用abstract修饰</p>
<p>③ abstract不能用来修饰私有方法、静态方法、final关键字修饰的方法、final关键字修饰的类</p>
<p>因为如果两个方法都是static，不认为两个方法是重写或者覆盖，所以abstract用来修饰静态方法，就无法重写</p>
</li>
</ol>
<h5 id="抽象的应用"><a href="#抽象的应用" class="headerlink" title="抽象的应用"></a>抽象的应用</h5><p>模板方法设计模式。在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤在父类中写好，某些易变的和不确定的部分可以抽象出来给子类实现。</p>
<h5 id="抽象类的匿名子类对象"><a href="#抽象类的匿名子类对象" class="headerlink" title="抽象类的匿名子类对象"></a>抽象类的匿名子类对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//匿名对象</span></span><br><span class="line">    eat(<span class="keyword">new</span> <span class="title class_">son</span>());</span><br><span class="line">    <span class="comment">//非匿名类的非匿名对象</span></span><br><span class="line">    son John=<span class="keyword">new</span> <span class="title class_">son</span>();</span><br><span class="line">    eat(John);</span><br><span class="line">    <span class="comment">//匿名子类对象</span></span><br><span class="line">    father f=<span class="keyword">new</span> <span class="title class_">father</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(father i)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(father f)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;<span class="comment">//抽象方法不能有方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(father i)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">father</span>&#123;<span class="comment">//继承</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上学&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(father i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+i.name+<span class="string">&quot; age:&quot;</span>+i.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、接口"><a href="#2、接口" class="headerlink" title="2、接口"></a>2、接口</h4><h5 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h5><ol>
<li><p>接口使用Interface来定义，和类是并列关系</p>
</li>
<li><p>接口的定义以及接口中的成员：</p>
<p>JDK7及以前：只能定义全局常量和抽象方法</p>
<ul>
<li>全局常量：都是用public static final定义的，可以省略不写</li>
<li>抽象方法：public abstract</li>
</ul>
<p>JDK8：除了全局常量和抽象方法，还可以定义静态方法和默认方法</p>
</li>
<li><p>接口中不能定义构造器，意味着接口不可以实例化，通过类去实现（implements）接口。</p>
<p>如果类覆盖了接口中所有的抽象方法，则可以创造实例；</p>
<p>如果类没有覆盖接口中所有的抽象方法，则该类仍为抽象类。</p>
</li>
<li><p>Java类可以实现多个接口——弥补了单继承性的缺陷</p>
<p>class AA extends BB implements CC,DD,EE</p>
</li>
<li><p>接口和接口之间可以继承，且可以多继承。接口的使用体现了多态性。</p>
</li>
<li><p>接口是一种规范，面向接口编程。</p>
</li>
<li><p>面试题：抽象类和接口有哪些异同？</p>
</li>
</ol>
<h5 id="接口应用"><a href="#接口应用" class="headerlink" title="接口应用"></a>接口应用</h5><ul>
<li>代理模式</li>
</ul>
<p>代理设计就是为其他对象提供一张代理以控制对这个对象的访问</p>
<p>应用场景：安全代理、远程代理、延迟加载</p>
<p>分类：静态代理、动态代理</p>
<ul>
<li>工厂模式</li>
</ul>
<p>实现创建者和调用者的分离</p>
<h5 id="接口笔试题"><a href="#接口笔试题" class="headerlink" title="接口笔试题"></a>接口笔试题</h5><ol>
<li><p>排错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pX</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().pX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：编译期不知道是要输出哪个x</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="built_in">super</span>.x);<span class="comment">//这个调用的是父类中的</span></span><br><span class="line">System.out.println(A.x);<span class="comment">//这个调用的是接口中的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>排错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Playable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bounceable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rollable</span> <span class="keyword">extends</span> <span class="title class_">Playable</span>,Bounceable&#123;</span><br><span class="line">    Ball ball=<span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;PingPong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> <span class="keyword">implements</span> <span class="title class_">Rollable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ball</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        ball=<span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;Football&quot;</span>);</span><br><span class="line">        System.out.println(ball.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Ball中的play()方法重写可以认为同时重写了Playable和Bounceable的play方法</li>
<li>Ball ball是public final的，不能再修改，所以ball&#x3D;new Ball(“Football”)是错误的</li>
</ul>
</li>
</ol>
<h5 id="java8中接口新特性"><a href="#java8中接口新特性" class="headerlink" title="java8中接口新特性"></a>java8中接口新特性</h5><p>JDK8：除了全局常量和抽象方法，还可以定义静态方法和默认方法（default关键字修饰）</p>
<ol>
<li>接口中定义的静态方法只能通过接口来调用，接口.方法。</li>
<li>通过实现类的对象，可以调用接口中的默认方法，对象.方法。如果实现类重写了接口中的默认方法，调用时仍然调用的是重写以后的方法</li>
<li>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的方法，子类在没有重写此方法的情况下调用的是父类中的方法——类优先原则</li>
<li>如果实现类实现了多个接口，而这个多个接口中定义了同名同参数的默认方法，在实现类没有重写方法的情况下会报”接口冲突“错误，此时需要重写。</li>
<li>如何在子类（或者实现类）调用父类、接口中被重写的方法，接口.super.方法</li>
</ol>
<h5 id="抽象类和接口的异同"><a href="#抽象类和接口的异同" class="headerlink" title="抽象类和接口的异同"></a>抽象类和接口的异同</h5><p>相同点：不能实例化，都可以包含抽象方法</p>
<p>不同点：</p>
<ol>
<li>把抽象类和接口（java7、java8)的定义、内部结构解释说明</li>
<li>类：单继承性，接口：多继承性</li>
</ol>
<h4 id="3、内部类"><a href="#3、内部类" class="headerlink" title="3、内部类"></a>3、内部类</h4><ol>
<li><p>Java允许将一个类A声明在另一个类B中，A为内部类，B为外部类</p>
</li>
<li><p>内部类的分类：成员内部类、局部内部类（方法内，代码块内，构造器内）</p>
</li>
<li><p>成员内部类</p>
<ul>
<li>作为外部类的成员：可以调用外部类的结构，可以被static修饰</li>
<li>作为一个类：可以定义属性、方法、构造器，可以用final、abstract修饰，可以被继承</li>
</ul>
</li>
<li><p>需要关注的问题：</p>
<ul>
<li><p>如何实例化成员内部类的对象：外部类Person，静态内部类Brain，非静态内部类Lungs</p>
<p>静态成员内部类：new 外部类.内部类()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.Brain brain=<span class="keyword">new</span> <span class="title class_">Person</span>.Brain();</span><br></pre></td></tr></table></figure>

<p>非静态成员内部类：先造对象，对象.new 内部类()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.Lungs lungs=p.<span class="keyword">new</span> <span class="title class_">Lungs</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何在成员内部类中区分调用外部类的结构</p>
<p>形参直接调，所在类的用this.结构，外部类的用外部类.this.结构</p>
</li>
<li><p>成员内部类和局部内部类在编译以后都会生成字节码文件</p>
<p>成员内部类：外部类$内部类名.class</p>
<p>局部内部类：外部类$数字 内部类名.class</p>
</li>
<li><p>在局部内部类的方法中，如果调用局部内部类所在的方法中的局部变量，该局部变量必须用final关键字修饰(JAVA8之后可以不写出来，但仍然还是final的)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AA</span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//局部内部类的方法</span></span><br><span class="line">            num=<span class="number">20</span>;<span class="comment">//试图修改会报错</span></span><br><span class="line">            System.out.println(num);<span class="comment">//调用局部内部类所在的方法中的局部变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>开发中局部内部类的使用</p>
<p>常用的局部内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getCompareble</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyComparable</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyComparable</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getCompareble</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">CompareTo</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="4、关键字总结"><a href="#4、关键字总结" class="headerlink" title="4、关键字总结"></a>4、关键字总结</h4><p>static可以用来修饰：属性、方法、代码块、内部类</p>
<p>final关键字可以用来修饰：类、方法、变量（属性和局部变量）</p>
<p>abstract可以用于修饰：类、方法</p>
<h2 id="第7章-异常处理"><a href="#第7章-异常处理" class="headerlink" title="第7章 异常处理"></a>第7章 异常处理</h2><h3 id="Day-15（P367-P385）"><a href="#Day-15（P367-P385）" class="headerlink" title="Day 15（P367-P385）"></a>Day 15（P367-P385）</h3><h4 id="1、异常概述与异常体系结构"><a href="#1、异常概述与异常体系结构" class="headerlink" title="1、异常概述与异常体系结构"></a>1、异常概述与异常体系结构</h4><p>JAVA.lang.Throwable：</p>
<ol>
<li>Error：JAVA虚拟机无法解决的严重问题</li>
<li>Exception：其他因变成错误或偶然的外在因素导致的一般性问题</li>
</ol>
<ul>
<li>编译时异常<ul>
<li>IOException</li>
<li>ClassNotFoundException</li>
</ul>
</li>
<li>运行时异常<ul>
<li>NullPointerException</li>
<li>ArrayIndexOutOfBoundsException</li>
</ul>
</li>
</ul>
<p>面试题</p>
<ol>
<li><p>常见的异常有哪些？举例说明</p>
</li>
<li><p>final&#x2F;finally&#x2F;finalize</p>
</li>
<li><p>throw&#x2F;throws</p>
<p>throw：抛出一个异常类的对象，生成异常对象的过程，声明在方法体内</p>
<p>throws：属于异常处理的方式，声明在方法体处</p>
</li>
<li><p>String &#x2F; StringBuffer &#x2F; StringBuilder</p>
</li>
<li><p>ArrayList &#x2F; LinkedList</p>
</li>
<li><p>HashMap &#x2F; LinkedHashMap</p>
</li>
<li><p>重写&#x2F;重载</p>
</li>
<li><p>&#x3D;&#x3D;&#x2F;equals</p>
</li>
<li><p>抽象类 &#x2F; 接口</p>
</li>
<li><p>sleep() &#x2F; wait()</p>
</li>
</ol>
<h4 id="2、常见异常"><a href="#2、常见异常" class="headerlink" title="2、常见异常"></a>2、常见异常</h4><ol>
<li><p>NullPointerException：空指针异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr=<span class="literal">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);<span class="comment">//空指针异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ArrayIndexOutOfBoundsException：数组角标越界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);<span class="comment">//数组角标越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ClassCastException类型转换异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Object obj=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    String s=(String)obj;<span class="comment">//类型转换异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NumberFormatException数值转换异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    String s=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num=Intger.parseInt(s);<span class="comment">//数值转换异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>InputMismatchException输入类型异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> score=scanner.nextInt();</span><br><span class="line">    System.out.println(score);<span class="comment">//输入“abc”，输入类型错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ArithmeticException算数异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    System.out.println(a/b);<span class="comment">//算数异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3、try-catch-finally"><a href="#3、try-catch-finally" class="headerlink" title="3、try-catch-finally"></a>3、try-catch-finally</h4><h5 id="异常的处理：抓抛模型"><a href="#异常的处理：抓抛模型" class="headerlink" title="异常的处理：抓抛模型"></a>异常的处理：抓抛模型</h5><ol>
<li>“抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码出生成一个对应异常类的对象并将此对象抛出，其后的代码就不再执行。</li>
<li>“抓”：可以理解为异常处理的方式：①try-catch-finally ②throws</li>
</ol>
<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    String s=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> num=Intger.parseInt(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----1-----&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出现数值转换异常&quot;</span>);<span class="comment">//出现异常时采取的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----2-----&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1不会输出，2会输出，因为一旦出现异常下面的代码就不再执行</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>finally是可选的，可以不写。</p>
</li>
<li><p>使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型去catch中进行匹配，一旦try中的对象匹配到某一个catch的时候就会进入异常的处理，一旦处理完成，如果没有写finally，就跳出当前的try-catch结构，继续执行其后的代码。</p>
</li>
<li><p>对异常的常用操作：①getMessage()返回String；②printStackTrace()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    String s=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> num=Intger.parseInt(s);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">        System.out.println(e.getMessage());<span class="comment">//输出For input string: &quot;abc&quot;</span></span><br><span class="line">         e.printStackTrace();<span class="comment">//非常具体的异常的位置和信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>finally的使用：即使catch中也出现了异常，try和catch里面还有return语句，finally都会执行，就是不管怎样都一定会执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(a/b);<span class="comment">//算数异常</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发生异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">at ExceptionExer.ExceptionTest.main(ExceptionTest.java:<span class="number">8</span>)	</span><br><span class="line">发生异常了</span><br></pre></td></tr></table></figure>
</li>
<li><p>finally的使用场景：数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动的进行资源释放，此时的资源释放需要声明在finally中。</p>
</li>
<li><p>try-catch-finally结构可以嵌套</p>
</li>
<li><p>使用try-catch-finally处理编译时已成，使得程序在编译时不再报错，但运行时仍可能保持，相当于把编译时可能出现的异常延迟到运行时出现。一般不针对运行时异常使用try-catch-finally，针对编译时异常需要做处理。</p>
</li>
</ol>
<h4 id="4、throws"><a href="#4、throws" class="headerlink" title="4、throws"></a>4、throws</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//main方法对异常进行处理</span></span><br><span class="line">        method();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException&#123;<span class="comment">//抛到main方法</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    System.out.println(a/b);<span class="comment">//算数异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws异常类型写在方法的声明处，指明此方法执行时，可能会抛出的异常类型，一旦方法体执行时出现异常仍然会异常代码处生成一个异常类的对象，此对象满足throws后异常类型时就会被抛出，异常代码后续的代码就<strong>不再执行</strong>（和try-catch-finally的不同点）。</p>
<h5 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h5><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<h5 id="开发中异常处理的选择"><a href="#开发中异常处理的选择" class="headerlink" title="开发中异常处理的选择"></a>开发中异常处理的选择</h5><ol>
<li>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能用throws</li>
<li>执行的方法A中先后调用了其他方法，方法和方法之间又有递进关系，这几个方法用throws，A中用try-catch-finally</li>
</ol>
<h4 id="5、手动抛出异常：throw"><a href="#5、手动抛出异常：throw" class="headerlink" title="5、手动抛出异常：throw"></a>5、手动抛出异常：throw</h4><p>异常的产生：①自动生成 ②手动抛出</p>
<h4 id="6、用户自定义异常类"><a href="#6、用户自定义异常类" class="headerlink" title="6、用户自定义异常类"></a>6、用户自定义异常类</h4><ol>
<li>继承于现有的异常结构：RuntimeException、Exception</li>
<li>提供全局常量：serialVersionUID，序列版本号 </li>
<li>提供重载的构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EcDef</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID=-<span class="number">33875164229948L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EcDef</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EcDef</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h2 id="第8章-多线程"><a href="#第8章-多线程" class="headerlink" title="第8章 多线程"></a>第8章 多线程</h2><h3 id="Day-15-（P406-P427）"><a href="#Day-15-（P406-P427）" class="headerlink" title="Day 15 （P406-P427）"></a>Day 15 （P406-P427）</h3><p>正式的多线程从P415开始</p>
<h4 id="1、程序、进程、线程"><a href="#1、程序、进程、线程" class="headerlink" title="1、程序、进程、线程"></a>1、程序、进程、线程</h4><p><strong>程序</strong>：一段静态的代码，静态对象</p>
<p><strong>进程</strong>：正在运行的一个程序，是一个动态的过程，有生命周期。进程作为资源分配的单位，系统在运行时会为每个进程分配内存区域。</p>
<p><strong>线程</strong>：进程可以进一步细化为线程，同一个进程可以支持多个线程就叫多线程</p>
<p>​           线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211126110036164.png" alt="image-20211126110036164"></p>
<p>每个线程各自有一套虚拟机栈和程序计数器</p>
<p>每个进程各有一份方法区和堆</p>
<p><strong>单核CPU和多核CPU</strong>：一个JAVA应用程序至少有三个线程，main主线程，gc()垃圾回收线程，异常处理线程</p>
<p><strong>并行和并发</strong>：并行——多个CPU同时执行多个任务</p>
<p>​                       并发——一个CPU同时执行多个任务</p>
<p><strong>多线程程序的优点：</strong></p>
<p>1、提高程序的响应。对图形化界面更有意义，可增强用户体验</p>
<p>2、提高计算机系统CPU的利用率</p>
<p>3、改善程序结构，进程分为线程独立运行，有利于理解和修改</p>
<h4 id="2、线程的创建和使用"><a href="#2、线程的创建和使用" class="headerlink" title="2、线程的创建和使用"></a>2、线程的创建和使用</h4><h5 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a>方式一：继承于Thread类</h5><p>1、创建Thread类的子类</p>
<p>2、重写Thread类的方法</p>
<p>3、创建Thread类的子类对象</p>
<p>4、通过此对象调用start()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MyThread t=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    t.start();<span class="comment">//①启动当前线程 ②调用当前线程的run()</span></span><br><span class="line">    <span class="comment">//匿名子类</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行的先后顺序并不会按照写的先后顺序，两个线程是并行的</span></span><br></pre></td></tr></table></figure>

<p>tips:</p>
<ol>
<li>不能通过run()的方式执行线程，用run()只是普通的调用方法</li>
<li>如果还要再启动一个线程，就再新造一个MyThread对象，再start()</li>
</ol>
<p>Thread里的常用方法：</p>
<ol>
<li>start()：①启动当前线程 ②调用当前线程的run()</li>
<li>run()：通常需要重写此方法</li>
<li>currentThread()：静态方法，返回执行当前代码的线程</li>
<li>getName()：获取当前线程的名字</li>
<li>setName()：设置当前线程的名字</li>
<li>yield()：释放当前CPU的执行权</li>
<li>join()：在线程A中调用B的该方法，线程A进入阻塞状态直到线程B执行完之后线程A才继续执行</li>
<li>sleep()：让当前线程强制阻塞</li>
</ol>
<p>线程的优先级：</p>
<ol>
<li>MAX——10，MIN——1，NORM——5（默认的优先级）</li>
<li>涉及的方法：getPriority()——返回线程的优先值，setPriority()——改变线程的优先级</li>
<li>高优先级的线程不一定就先执行，只是大概率先执行</li>
</ol>
<h5 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h5><ol>
<li>创建一个实现Runnable接口的类</li>
<li>实现类实现Runnable中的抽象方法：run()方法</li>
<li>创建实现类的对象</li>
<li>将对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过此对象调用start()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;<span class="comment">//创建一个实现Runnable接口的类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//实现类实现Runnable中的抽象方法：run()方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MyRun r=<span class="keyword">new</span> <span class="title class_">MyRun</span>();<span class="comment">//创建实现类的对象</span></span><br><span class="line">    Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(r);<span class="comment">//将对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">    t.start();<span class="comment">//通过此对象调用start()方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再启动一个线程</span></span><br><span class="line">     Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">     t1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a>两种方式的对比</h5><ol>
<li>Runnable没有单继承性的局限性，更适合多个线程共享数据的情况</li>
<li>相同点：都需要重写run并且将线程要执行的逻辑声明在run()中</li>
</ol>
<h3 id="Day-16（P428-P447）"><a href="#Day-16（P428-P447）" class="headerlink" title="Day 16（P428-P447）"></a>Day 16（P428-P447）</h3><h4 id="3、线程的生命周期"><a href="#3、线程的生命周期" class="headerlink" title="3、线程的生命周期"></a>3、线程的生命周期</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211201152708151.png" alt="image-20211201152708151"></p>
<h4 id="4、线程的同步"><a href="#4、线程的同步" class="headerlink" title="4、线程的同步"></a>4、线程的同步</h4><p>线程安全问题：</p>
<ul>
<li>多个线程执行的不确定性引起执行结果的不稳定性</li>
<li>多个线程对数据的共享会造成操作的不完整性，会破坏数据</li>
</ul>
<p>解决：当一个线程A在操作共享数据的时候其他线程不能参与，直到线程A操作完毕，也就是同步机制。</p>
<h5 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>操作共享数据的代码即为需要被同步的代码</li>
<li>共享数据：多个线程共同操作的变量</li>
<li>同步监视器，俗称锁。任何类的对象都可以充当锁，多个线程必须共用同一把锁。</li>
<li>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器；而在继承Thread类创建多线程的方式中，可以考虑使用当前类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步代码块+实现Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ticket=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//实现Runnable接口由于后面只创建一个对象，所以可以用Object并且不加static关键字，实现Thread类每个进程要创建一个对象，创建多个对象，所以不是同一个Object，加上static关键字才是共有的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyThread.class)&#123;<span class="comment">//类只会加载一次</span></span><br><span class="line">        <span class="comment">//synchronized (this)&#123;</span></span><br><span class="line">        <span class="comment">//实现Runnable接口由于后面只创建一个对象实现Runnable接口创建多线程的方式用this，代表唯一的对象，实现Thread类每个进程要创建一个对象，创建多个对象，所以不能用this</span></span><br><span class="line">        <span class="comment">//synchronized(obj)&#123;//造了三个对象，有三把锁，所以不能保证线程安全,</span></span><br><span class="line">            <span class="keyword">for</span> (tikect&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(getName()+<span class="string">&quot;买票，票号为：&quot;</span>+ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MyThread t1=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    MyThread t2=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    MyThread t3=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h5><p>如果操作共享数据的代码完整的声明在一个方法中，不妨将此方法声明为同步的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法+实现Runnable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//这里的同步监视器就是this</span></span><br><span class="line">        <span class="keyword">for</span> (tikect&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;买票，票号为：&quot;</span>+ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MyRun r=<span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line">    </span><br><span class="line">    Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    Thread t3=<span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步方法+实现Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不加static，那同步监视器是当前对象，必须是静态的,这里的同步监视器是当前类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (tikect&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread.getName()+<span class="string">&quot;买票，票号为：&quot;</span>+ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步方法总结"><a href="#同步方法总结" class="headerlink" title="同步方法总结"></a>同步方法总结</h5><p>非静态的同步方法，同步监视器是this，静态的同步方法，同步监视器是当前类本身</p>
<ul>
<li><p>同步代码块</p>
<ul>
<li><p>继承Thread类：用当前类当作同步监视器（MyThread.class）</p>
</li>
<li><p>实现Runnable接口：用this当同步监视器</p>
</li>
</ul>
</li>
<li><p>同步方法</p>
<ul>
<li><p>实现Runnable接口：直接用synchronized修饰方法，this当同步监视器</p>
</li>
<li><p>继承Thread类：需要用synchronized static修饰方法，当前类当同步监视器</p>
</li>
</ul>
</li>
</ul>
<h5 id="线程安全的单例模式：懒汉式"><a href="#线程安全的单例模式：懒汉式" class="headerlink" title="线程安全的单例模式：懒汉式"></a>线程安全的单例模式：懒汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        Bank.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//方法1:同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//加上synchronized</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>)instance=<span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法2:同步代码块（效率稍差）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance==<span class="literal">null</span>)instance=<span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//效率更高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="literal">null</span>)instance=<span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃，造成了线程的死锁，没有异常没有提示，但所有线程都在阻塞状态。</p>
<p>解决：①专门的算法、原则；②尽量减少同步资源的定义；③尽量避免嵌套同步</p>
<h5 id="Lock（锁）"><a href="#Lock（锁）" class="headerlink" title="Lock（锁）"></a>Lock（锁）</h5><p>从JDK5.0开始，JAVA提供了更强大的线程同步机制——通过显式定义同步锁来实现同步，同步锁使用Lock对象充当。java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.调用lock()方法</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;票号为：&quot;</span>+ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3.调用解锁的方法</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是继承Thread方式，private static ReentrantLock lock=new ReentrantLock(true)要加static</span></span><br></pre></td></tr></table></figure>

<p>面试题：</p>
<p>1、synchronized和lock的不同：</p>
<ol>
<li><p>Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)，synchronized是隐式锁，出了作用域自动释放</p>
</li>
<li><p>Lock只有代码块锁，synchronized有代码块锁和方法锁</p>
</li>
<li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性(提供更多的子类)</p>
</li>
</ol>
<p>2、优先使用顺序:</p>
<p>Lock &gt;同步代码块(已经进入了方法体，分配了相应资源) &gt;同步方法(在方法体之外）</p>
<p>3、解决线程安全问题</p>
<p>synchronized（分为同步代码块和同步方法）和锁</p>
<h4 id="5、线程的通信"><a href="#5、线程的通信" class="headerlink" title="5、线程的通信"></a>5、线程的通信</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                notify();<span class="comment">//*********</span></span><br><span class="line">                <span class="keyword">if</span> (num&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;当前数字：&quot;</span>+num);</span><br><span class="line">                    num++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();<span class="comment">//*********</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>涉及的三个方法：</p>
<ol>
<li><p>wait()：强制当前线程等待，直到某个其他线程在同一个对象上调用notify()或notifyAll()</p>
</li>
<li><p>notify()：唤醒wait中的一个线程，如果有多个线程被阻塞，则唤醒优先级高的那个</p>
</li>
<li><p>notifuAll()：唤醒所有wait中的线程</p>
</li>
</ol>
</li>
<li><p>说明：</p>
<ol>
<li>三个方法必须使用在同步代码块或者同步方法中</li>
<li>三个方法的调用者必须是同步监视器，否则会出现IllegalMonitorStateException异常</li>
<li>三个方法声明在Object类中</li>
</ol>
</li>
<li><p>面试题：sleep()和wait()的异同</p>
<p>相同点：一旦执行方法，都可以使当前线程进入阻塞状态</p>
<p>不同点：</p>
<ol>
<li>声明位置不同，sleep()声明在Thread类中，wait()声明在Object类中</li>
<li>调用的要求不同，sleep()可以在任何需要的场景下调用，wait()必须在同步代码块或者同步方法中</li>
<li>关于<strong>是否释放同步监视器</strong>，如果两个方法都使用在同步代码块或者同步方法中，wait()会释放同步监视器</li>
</ol>
</li>
</ul>
<h5 id="经典例题-生产者-x2F-消费者问题"><a href="#经典例题-生产者-x2F-消费者问题" class="headerlink" title="经典例题:生产者&#x2F;消费者问题"></a>经典例题:生产者&#x2F;消费者问题</h5><p>ps:建议多看这个视频加深理解P443</p>
<p>●生产者(Productor)将产品交给店员(Clerk),而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20)，如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产:如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p>
<p>●这里可能出现两个问题:</p>
<p>➢生产者比消费者快时，消费者会漏掉一些数据没有取到。</p>
<p>➢消费者比生产者快时，消费者会取相同的数据。</p>
<p>我理解的线程安全问题：两个线程分别生产和消费，但是操作了共同数据那就是产品，所以会出现线程安全问题，就是必须规定一段时间内只能生产或者只能消费</p>
<h4 id="6、JDK5-0新增线程创建方式"><a href="#6、JDK5-0新增线程创建方式" class="headerlink" title="6、JDK5.0新增线程创建方式"></a>6、JDK5.0新增线程创建方式</h4><h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5><p>1、与使用Runnable相比， Callable功能更强大些 </p>
<ul>
<li>相比run方法， 可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值 </li>
<li>需要借助FutureTask类， 比如获取返回结果</li>
</ul>
<p>2、Future接口</p>
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable类的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call方法中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//3.创建Callable实现类的对象</span></span><br><span class="line">    MyCall myCall=<span class="keyword">new</span> <span class="title class_">MyCall</span>();</span><br><span class="line">    <span class="comment">//4.将Callable实现类的对象传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">    FutureTask&lt;Integer&gt; myTask=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(myCall);<span class="comment">//可以使用泛型</span></span><br><span class="line">    <span class="comment">//5.将FutureTask的对象传递到Thread构造器中并调用start方法</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(myTask).start();<span class="comment">//启动线程还是要用start()方法</span></span><br><span class="line">    <span class="comment">//6.get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        myTask.get();<span class="comment">//可以得到返回值1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h5><p>开发中都是用线程池，好处：</p>
<ul>
<li>减少创建新线程的时间，提高响应速度</li>
<li>重复利用线程池中的线程降低资源消耗</li>
<li>便于线程管理</li>
</ul>
<p>1、JDK 5.0起提供了线程池相关API: ExecutorService 和Executors</p>
<p>2、ExecutorService:真正的线程池接口。常见子类ThreadPoolExecutor</p>
<ul>
<li>void execute(Runnable command):执行任务&#x2F;命令，没有返回值，一般用来执行Runnable</li>
<li><T> Future<T> submit(Callable<T> task); 执行任务，有返回值，一般又来执行Callable</li>
<li>void shutdown():关闭连接池</li>
</ul>
<p>3、Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池 ➢Exefutors newCachedThreadPool():创建一个可根据需要创建新线程的线程池 ➢Executors .newFixedThreadPool(n);创建一个可重用固定线程数的线程池</p>
<ul>
<li>Executors. newSingleThreadExecutor): 创建一个只有一个线程的线程池</li>
<li>Executors newScheduledThreadPool(n): 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1.提供指定数量的线程池</span></span><br><span class="line">    ExecutorService service= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2.执行指定的线程的操作，需要提供实现Runnable接口或者Callable接口实现类的对象</span></span><br><span class="line">    service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适用于Runnable</span></span><br><span class="line">    service.submit(<span class="keyword">new</span> <span class="title class_">MyCall</span>());<span class="comment">//适用于Callable</span></span><br><span class="line">    service.shutdown();<span class="comment">//3.关闭连接池</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h4><p>1、创建多线程有四种方式：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>使用线程池</li>
</ul>
<p>2、同步的方式：</p>
<ul>
<li><p>同步代码块</p>
<ul>
<li><p>继承Thread类：用当前类当作同步监视器（MyThread.class）</p>
</li>
<li><p>实现Runnable接口：用this当同步监视器</p>
</li>
</ul>
</li>
<li><p>同步方法</p>
<ul>
<li>继承Thread类：直接用synchronized修饰方法，this当同步监视器</li>
<li>实现Runnable接口：需要用synchronized static修饰方法，当前类当同步监视器</li>
</ul>
</li>
<li><p>定义同步锁</p>
</li>
</ul>
<p>3、释放锁的操作</p>
<ul>
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步代码块、同步方法中遇到break、returm终止了该代码块、该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception,导致异常结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ul>
<p>4、不会释放锁的操作</p>
<ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread sleep()、 Thread. yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法（挂起）将该线程挂起，该线程不会释放锁(同步监视器)</li>
</ul>
<p>ps:应尽量避免使用suspend()和resume()来控制线程</p>
<h2 id="第9章-JAVA常用类"><a href="#第9章-JAVA常用类" class="headerlink" title="第9章 JAVA常用类"></a>第9章 JAVA常用类</h2><h3 id="1、字符串相关的类"><a href="#1、字符串相关的类" class="headerlink" title="1、字符串相关的类"></a>1、字符串相关的类</h3><h4 id="String类及常用方法"><a href="#String类及常用方法" class="headerlink" title="String类及常用方法"></a>String类及常用方法</h4><ol>
<li><p>String定义了final char[] value用于存储字符串数据，代表不可变的字符序列。</p>
<ul>
<li>对字符串重新赋值时，需要重写指定内存区赋值，不能使用原有的value进行赋值</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li>
</ul>
</li>
<li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口，表示String可以比较大小</p>
</li>
<li><p>通过字面量的方式给一个字符串赋值，此时字符串值声明在字符串常量池中，字符串常量池中是不会存储相同内容的字符串的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String st1=<span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量，存储在字符串常量池中，目的是共享</span></span><br><span class="line">String st2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//字符串非常量对象存储在堆中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>面试题：<code>String s=new String(&quot;abc&quot;)</code>方式创建对象，在内存中创建了几个对象？</p>
<p>两个，一个是堆空间中new的结构，另一个是<code>char[]</code>对应常量池中的数据“abc”</p>
</li>
<li><p>不同拼接操作的对比</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;leet&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;Code&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s3=<span class="string">&quot;leetCode&quot;</span>;</span><br><span class="line">String s4=<span class="string">&quot;leet&quot;</span>+<span class="string">&quot;Code&quot;</span>;</span><br><span class="line">String s5=s1+<span class="string">&quot;Code&quot;</span>;</span><br><span class="line">String s6=<span class="string">&quot;leet&quot;</span>+s2;</span><br><span class="line">String s7=s1+s2;</span><br><span class="line"></span><br><span class="line">String s8=s5.intern();<span class="comment">//返回值得到的s8使用的是常量池中的字符串</span></span><br><span class="line"></span><br><span class="line">s3==s4;<span class="comment">//true，都是在常量池中</span></span><br><span class="line">s3==s5;<span class="comment">//false，只要有变量参与，都在堆中</span></span><br><span class="line">s3==s6;<span class="comment">//false</span></span><br><span class="line">s3==s7;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ol>
<li>常量与常量的拼接结果在常量池，且常量池中不会存在相同容量的常量</li>
<li>只要其中有一个是变量，结果就在堆中</li>
</ol>
</li>
<li><p>JVM中涉及字符串的内存结构</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211204204821092.png" alt="image-20211204204821092"></p>
</li>
<li><p>String中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>;<span class="comment">//转小写</span></span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>;<span class="comment">//转大写，字符串本身不变，需要新建字符串接收</span></span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>;<span class="comment">//去除收尾空格</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">()</span>;<span class="comment">//和equals类似，忽略大小写</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CompareTo</span><span class="params">()</span>;<span class="comment">//比较两个字符串的大小，负数则当前字符串小</span></span><br><span class="line">String <span class="title function_">subString</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">()</span>;<span class="comment">//是否以指定的字符串结束</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix,<span class="type">int</span> toffset)</span>;<span class="comment">//指定索引位置开始的子字符串是否以指定前缀开始</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String和其他基本数据类型和包装类的转换</p>
<p>String—&gt;基本数据类型、包装类：调用包装类的静态方法parseXxx(str)</p>
<p>基本数据类型、包装类—&gt;String：调用String重载的valueOf(xxx)</p>
</li>
<li><p>String和char[]的转换</p>
<p>String—&gt;char[]：str.toCharArray</p>
<p>char[]—&gt;String：调用String的构造器</p>
</li>
<li><p>String和byte[]的转换</p>
<p>String—&gt;byte[]：调用String的getBytes()方法</p>
<p>byte[]—&gt;String：调用String的构造器</p>
</li>
<li><p>&#96;&#96;&#96;java<br>final String s1&#x3D;”leet”;<br>String s2&#x3D;”Code”;<br>String s3&#x3D;”leetCode”;<br>String s4&#x3D;s1+”Code”;<br>s3&#x3D;&#x3D;s4;&#x2F;&#x2F;true,因为s1是常量，操作在常量池中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### StringBuffer/StringBuilder</span><br><span class="line"></span><br><span class="line">1. String、StringBuffer和StringBuilder的区别？</span><br><span class="line"></span><br><span class="line">   String：不可变的序列，底层使用char[]存储</span><br><span class="line"></span><br><span class="line">   StringBuffer：可变的序列，线程安全，效率稍低，底层使用char[]存储</span><br><span class="line"></span><br><span class="line">   StringBuilder：可变的序列，线程不安全，效率稍高，底层使用char[]存储</span><br><span class="line"></span><br><span class="line">   效率：StringBuilder &gt; StringBuffer &gt; String</span><br><span class="line"></span><br><span class="line">   String-----&gt;StringBuffer和StringBuilder:调用StringBuffer和StringBuilder的构造器</span><br><span class="line"></span><br><span class="line">   StringBuffer和StringBuilder-----&gt;String:调用String的构造器</span><br><span class="line"></span><br><span class="line">2. 源码分析</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   String str=new String();//new char[0]</span><br><span class="line">   String str=new String(&quot;abc&quot;);//new char[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span><br><span class="line">   StringBuffer sb=new StringBuffer();//char[] value=new char[16],底层造了一个长度为16的数组</span><br><span class="line">   StringBuffer sb1=new StringBuffer(&quot;abc&quot;);//char[] value=new char[&quot;abc&quot;.length()+16];</span><br><span class="line">   问题1：System.out.println(sb1.length());//输出3而不是19</span><br><span class="line">   问题2：如果要添加的数据底层数组撑不下了，默认情况下会扩容为原来容量的2倍+2，同时将原来数组的元素赋值到新的数组中</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2、JDK8之前的日期时间API"><a href="#2、JDK8之前的日期时间API" class="headerlink" title="2、JDK8之前的日期时间API"></a>2、JDK8之前的日期时间API</h3><h4 id="System静态方法"><a href="#System静态方法" class="headerlink" title="System静态方法"></a>System静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillis();<span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差，时间戳</span></span><br></pre></td></tr></table></figure>

<h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p> 1、java.util.Date类</p>
<p>表示特定的瞬间，精确到毫秒</p>
<ul>
<li>构造器</li>
</ul>
<p>Date():使用无参构造器创建的对象可以获取本地当前时间。</p>
<p>Date(long date)：创建指定毫秒数的对象</p>
<ul>
<li>常用方法</li>
</ul>
<p>getTime():返回自1970 年1月 1 日 00:00:00 GMT 以来此Date对象表示的毫秒数。</p>
<p>toString()：把Date 对象转换为以下形式的String: dow mon dd hh:mm:ss zzz yyy其中: dow 是一周中的某一天(Sun, Mon, Tue, Wed, Thu, Fri, Sat), zzz是时间标准 </p>
<p>其它很多方法都过时了</p>
<p>2、 java.sql.Date类对应数据库中的日期类型的变量</p>
<ul>
<li><p>实例化：java.sql.Date date&#x3D;new  java.sql.Date();</p>
</li>
<li><p>将util.Date类转化为sql.Date类，sql.Date类是util.Date类的子类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date date=<span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">3253834753L</span>);<span class="comment">//多态</span></span><br><span class="line">java.sql.Date date1= (java.sql.Date) date;<span class="comment">//强转</span></span><br><span class="line"></span><br><span class="line">Date date=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">java.sql.Date date1= (java.sql.Date) date;<span class="comment">//父类对象强转运行会报错</span></span><br><span class="line">java.sql.Date date1= <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date.getTime());</span><br></pre></td></tr></table></figure>

<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><p>java.util.Calendar(日历)类</p>
<p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</p>
<ul>
<li>获取Calendar实例的方法</li>
</ul>
<p>使用Calendar.getInstance()方法</p>
<p>调用它的子类GregorianCalenda的构造器</p>
<p>●一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY _OF WEEK、HOUR OF DAY、。MINUTE、SECOND</p>
<p>➢public void set(int field,int value)</p>
<p>➢public void add(int field,int amount)</p>
<p>➢public final Date getTime()</p>
<p>➢public final void setTime(Date date)</p>
<p>➢获取月份时：一月是0，二月是1，以此类推，12月是11</p>
<p>➢获取星期时：周日是1,周二是2，。。。。周六是7</p>
<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><p>SimpleDateFormat的使用：排队日期Date类的格式化和解析，格式化：日期—&gt;字符串，解析：字符串—&gt;日期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date);<span class="comment">//输出Sun Dec 05 14:28:58 CST 2021</span></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date);</span><br><span class="line">    System.out.println(format);<span class="comment">//输出21-12-5 下午2:28</span></span><br><span class="line">    <span class="comment">//解析</span></span><br><span class="line">    String s=<span class="string">&quot;21-12-5 下午2:31&quot;</span>;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(s);</span><br><span class="line">    System.out.println(parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习题1：将字符串”2020-09-08”转换为java.sql.Date</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">Date date1=s1.parse(s);</span><br><span class="line">java.sql.Date date2=<span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date1.getTime());</span><br></pre></td></tr></table></figure>

<p>练习题2：三天打鱼两天晒网，1990-01-01，2020-09-08打鱼还是晒网，其实就是求总天数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    SimpleDateFormat s1=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    Date date1=s1.parse(<span class="string">&quot;1999-01-01&quot;</span>);</span><br><span class="line">    Date date2=s1.parse(<span class="string">&quot;2020-09-08&quot;</span>);</span><br><span class="line">    Long day=(date2.getTime()-date1.getTime())/(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br><span class="line">    Long res=day%<span class="number">5</span>;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、JDK8中新日期时间API"><a href="#3、JDK8中新日期时间API" class="headerlink" title="3、JDK8中新日期时间API"></a>3、JDK8中新日期时间API</h3><h4 id="LocalDate-x2F-LocalTime-x2F-LocalDateTime"><a href="#LocalDate-x2F-LocalTime-x2F-LocalDateTime" class="headerlink" title="LocalDate&#x2F;LocalTime&#x2F;LocalDateTime"></a>LocalDate&#x2F;LocalTime&#x2F;LocalDateTime</h4><p>LocalDateTime最常用</p>
<h4 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h4><p>时间线上的一个瞬时点</p>
<h4 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><h3 id="4、JAVA比较器"><a href="#4、JAVA比较器" class="headerlink" title="4、JAVA比较器"></a>4、JAVA比较器</h3><h4 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h4><p>自然排序</p>
<h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h4><p>定制排序：重写compare(Object o1,Object o2)方法比较大小v  </p>
<h3 id="5、System类"><a href="#5、System类" class="headerlink" title="5、System类"></a>5、System类</h3><h3 id="6、Math类"><a href="#6、Math类" class="headerlink" title="6、Math类"></a>6、Math类</h3><h3 id="7、BigInteger与BigDecimal"><a href="#7、BigInteger与BigDecimal" class="headerlink" title="7、BigInteger与BigDecimal"></a>7、BigInteger与BigDecimal</h3><p>BigInteger可以表示不可变的任意精度的整数</p>
<p>要求数字精度比较高，会用到BigDecimal</p>
<h2 id="第10章-枚举类-amp-注解"><a href="#第10章-枚举类-amp-注解" class="headerlink" title="第10章 枚举类&amp;注解"></a>第10章 枚举类&amp;注解</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><h3 id="1、如何自定义枚举类"><a href="#1、如何自定义枚举类" class="headerlink" title="1、如何自定义枚举类"></a>1、如何自定义枚举类</h3><p>当一个类的对象只有有限确定个数时我们称此类为枚举类，当需要定义一组常量时强烈建议用枚举类</p>
<p>JDK5.0之前，自定义枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性：private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">	<span class="comment">//2.私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//3.提供当前枚举类的多个对象：public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER=<span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、如何使用关键字enum定义枚举类"><a href="#2、如何使用关键字enum定义枚举类" class="headerlink" title="2、如何使用关键字enum定义枚举类"></a>2、如何使用关键字enum定义枚举类</h3><p>JDK5.0之后，可以使用enum关键字定义枚举类</p>
<p>默认继承于class java.lang.Enum</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、Enum类的主要方法"><a href="#3、Enum类的主要方法" class="headerlink" title="3、Enum类的主要方法"></a>3、Enum类的主要方法</h3><p>values()方法: 返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值</p>
<p>valueOf(String str):可以把一个字符串转为对应的枚举类对象。 要求字符面串必须是枚举类对象的“名字”。如不是，会有运行时异常:llegalArgumentException.</p>
<p>toString(): 返回当前枚举类对象常量的名称</p>
<h3 id="4、实现接口的枚举类"><a href="#4、实现接口的枚举类" class="headerlink" title="4、实现接口的枚举类"></a>4、实现接口的枚举类</h3><ol>
<li><p>在enum类中实现抽象方法，和一般类相同</p>
</li>
<li><p>每一个对象可以重写方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>1、注解概述:P505</p>
<p>2、常见的Annotation示例</p>
<p>@Overide @Deprecated @SuppressWarnings</p>
<p>3、自定义Annotation</p>
<p>参照SuppressWarnings定义</p>
<p>①注解声明为: @interface</p>
<p>②内部定义成员，通常使用value表示</p>
<p>③可以指定成员的默认值， 使用default定义</p>
<p>④如果自定义注解没有成员，表明是一个标识作用。</p>
<p>自定义注解必须使用反射才有意义</p>
<p>4、JDK中的四种元注解</p>
<p>用于修饰其他注解</p>
<p><strong>Retention</strong>：指定所修饰的Annotation的生命周期：SOURCE&#x2F;CLASS(默认行为)&#x2F;RUNTIME</p>
<p>只有声明为RUNTIME生命周期的注解才能通过反射获取</p>
<p><strong>Target</strong>：用于指定被修饰的Annotation能用于修饰哪些程序元素</p>
<p>————以下出现频率较低</p>
<p><strong>Documented</strong>：表示所修饰的注解在被javadoc解析时保留下来</p>
<p><strong>Inherited</strong>：所修饰的注解具有继承性</p>
<p>5、利用反射获取注解信息</p>
<p>6、JDK8中注解的新特性：可重复注解、类型注解</p>
<p><strong>可重复注解</strong>：</p>
<p>① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotation.class</p>
<p>② MyAnnotation的Target和Retention等元注解必须和Annotations相同</p>
<p><strong>类型注解</strong>：</p>
<p>➢ElementType.TYPE_PARAMETER表示该注解能写在类型变量的声明语句中(如:泛型声明)</p>
<p>➢ElementType.TYPE_USE表示该注解能写在使用类型的任何语句中。</p>
<h2 id="第11章-JAVA集合"><a href="#第11章-JAVA集合" class="headerlink" title="第11章 JAVA集合"></a>第11章 JAVA集合</h2><h3 id="1、JAVA集合框架概述"><a href="#1、JAVA集合框架概述" class="headerlink" title="1、JAVA集合框架概述"></a>1、JAVA集合框架概述</h3><p>Java集合可以分为两种体系：</p>
<ul>
<li><strong>Collection接口</strong>：单列数组</li>
</ul>
<p>List：元素有序、可重复的集合——ArrayList\LinkedList\Vector</p>
<p>Set：元素无序、不可重复的集合——HashSet\LinkedHashSet\TreeSet</p>
<ul>
<li><strong>Map接口</strong>：具有映射关系的“key-value”集合——<strong>HashMap</strong>\LinkedHashMap\TreeMap\Hashtable\Properties</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211208142527668.png" alt="image-20211208142527668"></p>
<h3 id="2、Collection接口方法"><a href="#2、Collection接口方法" class="headerlink" title="2、Collection接口方法"></a>2、Collection接口方法</h3><ol>
<li><p>contains()用的是equals方法，如果是String对象，重写过那就是比较内容，不然就是比较地址</p>
</li>
<li><p>retainAll相当于是求交集</p>
</li>
<li><p>hashCode()：求哈希值</p>
</li>
<li><p>toArray()：集合—-&gt;数组</p>
</li>
<li><p>Arrays.asList()：数组—–&gt;集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>[]&gt; list1 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);<span class="comment">//要用包装类</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>iterator()：返回iterator接口的实例，用于遍历集合元素</p>
</li>
</ol>
<h3 id="3、Iterator迭代器接口"><a href="#3、Iterator迭代器接口" class="headerlink" title="3、Iterator迭代器接口"></a>3、Iterator迭代器接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection coll=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());<span class="comment">//输出1</span></span><br><span class="line">&#125;</span><br><span class="line">iterator.remove();<span class="comment">//迭代器也有remove方法</span></span><br></pre></td></tr></table></figure>

<p>jdk 5.0新增了foreach循环，用于遍历集合和数组</p>
<h3 id="4、Collection子接口一：List"><a href="#4、Collection子接口一：List" class="headerlink" title="4、Collection子接口一：List"></a>4、Collection子接口一：List</h3><p>面试题：ArrayList\LinkedList\Vector三者异同？</p>
<p>相同：都实现了List接口，存储数据的特点相同</p>
<p>不同：ArrayList——List接口的主要实现类，执行效率高，线程不安全，底层使用Object[]存储</p>
<p>LinkedList——使用双向链表存储，对于频繁的插入删除操作效率比ArrayList高</p>
<p>Vector——执行效率低，线程安全，底层使用Object[]</p>
<h4 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h4><ol>
<li><p>jdk 7情况下：</p>
<p>ArrayList list &#x3D; new ArrayList();&#x2F;&#x2F;底层创建了长度是1的Object[]数组eLementData</p>
<p>list. add(123);&#x2F;&#x2F;eLementData[e] &#x3D; new Integer(123);</p>
<p>list. add(11);&#x2F;&#x2F;如果此次的添加导致底层eLementData数组容量不够，则扩容。</p>
<p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p>
<p>结论:建议开发中使用带参的构造器: ArrayList list &#x3D; new Arraylist(int capacity)</p>
</li>
<li><p>jdk 8中ArrayList的变化:</p>
<p>Arraylist list &#x3D; new ArrayList();&#x2F;&#x2F;底层Object[] elementData 初始化为{}.并没有创建长度</p>
<p>list. add(123);&#x2F;&#x2F;第一次调用add()时，底层才创建了长度10的数组</p>
<p>后续的添加和扩容与jdk7无异</p>
</li>
</ol>
<h4 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h4><p>是双向链表</p>
<h3 id="5、Collection子接口二：Set"><a href="#5、Collection子接口二：Set" class="headerlink" title="5、Collection子接口二：Set"></a>5、Collection子接口二：Set</h3><ul>
<li><p>HashSet：线程不安全，可以存储null值，底层是HashMap</p>
</li>
<li><p>LinkedHashSet：遍历数据是可以按照添加的顺序顺序遍历</p>
</li>
<li><p>TreeSet：可以按照添加对象的指定属性进行排序，底层是用红黑树储存的</p>
</li>
</ul>
<ol>
<li>无序性：不等于随机性，是存储的数据在底层数组中并非按照索引添加，而是按照哈希值添加</li>
<li>不可重复性：本质上使用equals做的比较</li>
</ol>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>我们向HashSet中添加元素,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接者通过某种算法计算出在HashSet底层数组中的存放位置(即为:索引位置)，判断数组此位置上是否已经有元素。</p>
<ul>
<li><p>如果此位置上没有其他元素，则元素a添加成功。</p>
</li>
<li><p>如果此位置上有其他元素b(或以链表形式存在的多个元素)，则比较元素a与元素的hash值:</p>
<ul>
<li><p>如果hash值不相同，则元素a添加成功。</p>
</li>
<li><p>如果hash值相同，进而需要调用元素a所在类的equlas()方法:</p>
</li>
</ul>
</li>
</ul>
<p>equals()返回true,元素a添加失败</p>
<p>equals()返回false,则元素七上八下，JDK7之前是在当前元素之前，JDK8之后是在当前元素之后</p>
<p>像set中添加的数据其所在的类一定要重写hashCode()和equals()并保持一致性，直接用系统生成的</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>是HashSet的子类因为是有序的，所以频繁遍历的效率高于HashSet</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>添加的数据必须是相同类型的对象</p>
<p>排序可以自然排序（实现compareble接口）和定制排序，自然排序中比较对象是否相同的标准为compareTo()返回0而不是equals()</p>
<h3 id="set习题"><a href="#set习题" class="headerlink" title="set习题"></a>set习题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    HashSet set=<span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;AA&quot;</span>,<span class="number">1001</span>);</span><br><span class="line">    Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;BB&quot;</span>,<span class="number">1002</span>);</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    p1.name=<span class="string">&quot;CC&quot;</span>;<span class="comment">//将AA 1001对应哈希值的位置改了属性</span></span><br><span class="line">    set.remove(p1);<span class="comment">//找CC 1001对应的哈希值删除，结果没找到</span></span><br><span class="line">    System.out.println(set);<span class="comment">//还是输出两个元素</span></span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;CC&quot;</span>,<span class="number">1001</span>));<span class="comment">//放入CC 1001对应哈希值的位置</span></span><br><span class="line">    System.out.println(set);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;AA&quot;</span>,<span class="number">1001</span>));<span class="comment">//找到AA 1001对应哈希值的位置，但该位置放的是CC，所以成功添加</span></span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、Map接口"><a href="#6、Map接口" class="headerlink" title="6、Map接口"></a>6、Map接口</h3><h4 id="Map实现类结构"><a href="#Map实现类结构" class="headerlink" title="Map实现类结构"></a>Map实现类结构</h4><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211208142444965.png" alt="image-20211208142444965" style="zoom: 67%;" />



<ul>
<li><p>HashMap：Map的主要实现类，线程不安全，效率高，可以存储null的key和value</p>
<ul>
<li>LinkedHashMap：在原有的HashMap底层结构上添加了一堆指针指向前一个和后一个元素，保证在遍历元素时按照添加的顺序实现遍历，对于频繁的遍历操作，此类执行效率高于HashMap</li>
</ul>
</li>
<li><p>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历，使用key的自然或者定制排序</p>
</li>
<li><p>Hashtable：作为古老的实现类，线程安全效率低，不能存储null的key和value</p>
<ul>
<li>Properties：Properties 类是 Hashtable 的子类，该对象用于处理属性文件，由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key  和 value 都是字符串类型</li>
</ul>
</li>
</ul>
<p>HashMap底层：数组+链表（JDK7之前</p>
<p>​                            数组+链表+红黑树（JDK8</p>
<p>面试题：</p>
<ol>
<li>HashMap底层实现原理？</li>
<li>HashMap和Hashtable的异同？</li>
<li>CurrentHashMap与Hashtable的异同？</li>
</ol>
<h4 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h4><p>Map中的key:无序的、不可重复的，使用Set 存储所有的key，key所在类要重写equals和hashCode方法</p>
<p>Map中的value:无序的、可重复的，使用Collection 存储所有的vaLue</p>
<p>一个键值对: key-value 构成了一个Entry对象。</p>
<p>Map中的entry:无序的、不可重复的，使用set存储所有entry</p>
<h4 id="HashMap-JDK7"><a href="#HashMap-JDK7" class="headerlink" title="HashMap JDK7"></a>HashMap JDK7</h4><h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//在实例化以后，底层创建了长度是16的一维数组Entry[] table</span></span><br><span class="line">map.put(key1,value1);</span><br></pre></td></tr></table></figure>

<p>首先调用Key1所在类的hashCode方法计算key1哈希值，哈希值经过计算之后得到Entry数组中的存放位置</p>
<ol>
<li>如果数据为空，添加成功</li>
<li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在，JDK放在上面，就是当前添加的数据的next是原来的数据))，比较key1和已经存在的一个或多个数据的哈希值:<ol>
<li>如果key1的哈希值与己经存在的数据的哈希值都不相同，此时key1-value1添加成功。</li>
<li>如果key1的哈希值和已经存在的某一个数据的哈希值相同， 继续比较:调用key1所在类的equals()方法，比较: <ol>
<li>如果equals()返回false:此时key1-value1添加成功</li>
<li>如果equals()返@true:使用新value替换旧value</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>在添加过程中会涉及到扩容问题，默认扩容为原来的2倍，之前的数据需要重新计算存放位置</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>P552</p>
<h4 id="HashMap-JDK8"><a href="#HashMap-JDK8" class="headerlink" title="HashMap JDK8"></a>HashMap JDK8</h4><h5 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h5><p>相较于JDK7 底层实现的不同：</p>
<ol>
<li><p>new HashMap():底层没有创建-一个长度为16的数组</p>
</li>
<li><p>jdk 8底层的数组是: Node[], 而非Entry[]</p>
</li>
<li><p>首次调用put()方法时，底层创建长度为16的数组</p>
</li>
<li><p>JDK7：数组+链表，JDK8：数组+链表+红黑树</p>
<p>当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64，此时所以位置上的所有数据改为红黑树存储（查找效率高很多</p>
</li>
</ol>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>DEFAULT_ INITIAL_ CAPACITY : HashMap的默认容量，16</p>
<p>DEFAULT_ LOAD FACTOR: HashMap的默认加载因子: 0.75</p>
<p>threshold:扩容的临界值，&#x3D;容量*填充因子: 16 * 0.75 &#x3D;&gt; 12</p>
<p>TREEIFY THRESHOLD: Bucket 中链表长度大于该默认值，转化为红黑树:8 </p>
<p>MIN TREEIFY CAPACITY:桶中的Node被树化时最小的hash表容量:64</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>PS:了解就可以了</p>
<p>HashMap中的内部类：Node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap中的内部类：Entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    	<span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map中定义的方法"><a href="#Map中定义的方法" class="headerlink" title="Map中定义的方法"></a>Map中定义的方法</h4><p>元视图操作的方法： </p>
<p>Set keySet()：返回所有key构成的Set集合 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set set=map.keySet();</span><br></pre></td></tr></table></figure>

<p>Collection values()：返回所有value构成的Collection集合 </p>
<p>Set entrySet()：返回所有key-value对构成的Set集合</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。</p>
<p> TreeMap 可以保证所有的 Key-Value 对处于有序状态。</p>
<p>TreeSet底层使用红黑树结构存储数据 </p>
<p>TreeMap 的 Key 的排序：</p>
<ul>
<li><p>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有 的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException </p>
</li>
<li><p>定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</p>
</li>
</ul>
<p>TreeMap判断两个key相等的标准：两个key通过compareTo()方法或 者compare()方法返回0。</p>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件，由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key  和 value 都是字符串类型</p>
<h3 id="7、Collections工具类"><a href="#7、Collections工具类" class="headerlink" title="7、Collections工具类"></a>7、Collections工具类</h3><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类</p>
<p>Collection和Collections的区别?Collection是接口，Collections是工具类</p>
<ul>
<li>void copy(List dest,List src)：将src中的内容复制到dest中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="number">345</span>);</span><br><span class="line">List list1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">Collections.copy(list1,list);<span class="comment">//IndexOutOfBoundsException: Source does not fit in dest</span></span><br><span class="line"><span class="comment">//lsit1容量比list小</span></span><br><span class="line">List list1=Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);<span class="comment">//这样就容量一样了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集 合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全 问题</li>
</ul>
<h2 id="第12章-泛型"><a href="#第12章-泛型" class="headerlink" title="第12章 泛型"></a>第12章 泛型</h2><h3 id="1、为什么要有泛型"><a href="#1、为什么要有泛型" class="headerlink" title="1、为什么要有泛型"></a>1、为什么要有泛型</h3><p>任何类型都可以添加到集合中：类型不安全</p>
<p>读取出来的对象需要强转：繁琐，可能有ClassCastException</p>
<h3 id="2、在集合中使用泛型"><a href="#2、在集合中使用泛型" class="headerlink" title="2、在集合中使用泛型"></a>2、在集合中使用泛型</h3><p>集合类或者集合接口都在JDK5.0的时候修改为带泛型的结构</p>
<p>泛型的类型必须是类，如果是基本数据类型则用包装类</p>
<h3 id="3、自定义泛型结构"><a href="#3、自定义泛型结构" class="headerlink" title="3、自定义泛型结构"></a>3、自定义泛型结构</h3><p>泛型类&#x2F;泛型接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类，如果定义了泛型类，实例化时没有指明类型，则认为此时泛型类型为Object类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    T orderT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String name, <span class="type">int</span> age, T orderT)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于子类在继承带泛型的父类时同样继承了泛型，新建对象时不需要指明泛型，此时子类不是泛型类</p>
<p>泛型方法</p>
<p>在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系，泛型方法所属的类是不是泛型类都没有关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">pro</span><span class="params">(E[] arr)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、泛型在继承上的体现"><a href="#4、泛型在继承上的体现" class="headerlink" title="4、泛型在继承上的体现"></a>4、泛型在继承上的体现</h3><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，<code>G&lt;B&gt;</code><strong>并不是</strong><code>G&lt;A&gt;</code>的子类型</p>
<h3 id="5、通配符的使用"><a href="#5、通配符的使用" class="headerlink" title="5、通配符的使用"></a>5、通配符的使用</h3><p>List&lt;?&gt;是List<Integer>、List<Long>等各种泛型List的父类</p>
<p>list&lt;?&gt;不能向其内部添加数据。因为我们不知道c的元素类型，我们不能向其中添加对象，<strong>null除外</strong></p>
<p>有限制条件的通配符的使用：</p>
<p>？extends Person：&lt;&#x3D;</p>
<p>?  super Person：&gt;&#x3D;</p>
<h2 id="第13章IO流"><a href="#第13章IO流" class="headerlink" title="第13章IO流"></a><strong>第13章IO流</strong></h2><h3 id="1、File类的使用"><a href="#1、File类的使用" class="headerlink" title="1、File类的使用"></a>1、File类的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file);<span class="comment">//hello.txt</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;\&quot;C:\\Users\\86187\\Desktop\\hotel.txt\&quot;&quot;</span>);</span><br><span class="line">    System.out.println(file1);<span class="comment">//&quot;C:\Users\86187\Desktop\hotel.txt&quot;</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;\&quot;C:\\Users\\86187\\Desktop\&quot;&quot;</span>,<span class="string">&quot;JavaSenior&quot;</span>);</span><br><span class="line">    System.out.println(file2);<span class="comment">//&quot;C:\Users\86187\Desktop&quot;\JavaSenior</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file2,<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    System.out.println(file3);<span class="comment">//&quot;C:\Users\86187\Desktop&quot;\JavaSenior\hi.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>File类的一个对象，代表一个文件或者一个文件目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String filePath)</span><br><span class="line">File(String parentPath,String childPath)</span><br><span class="line">File(File parentFile,String childPath)</span><br></pre></td></tr></table></figure>
</li>
<li><p>File类声明在java.io包下，路径可以分为相对路径和绝对路径</p>
<p>相对：相较于某个路径下指明的路径</p>
<p>绝对：包含盘符在内的文件或者文件目录的路径</p>
</li>
<li><p>常用方法</p>
<p>涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读入文件内容的操作，如果需要读取或写入文件内容，必须使用IO流来完成</p>
</li>
<li><p>后续File类的对象通常会作为参数传递到流的构造器中，指明读取或者写入的终点</p>
</li>
</ol>
<h3 id="2、IO流原理及流的分类"><a href="#2、IO流原理及流的分类" class="headerlink" title="2、IO流原理及流的分类"></a>2、IO流原理及流的分类</h3><ul>
<li><p>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit) </p>
</li>
<li><p>按数据流的流向不同分为：输入流，输出流 </p>
</li>
<li><p>按流的角色的不同分为：节点流，处理流</p>
</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211210142652719.png" alt="image-20211210142652719" style="zoom:50%;" />

<p>重点：缓冲流、转换流、对象流</p>
<p>了解：标准打印输入、输出流、打印流、数据流、随机存取文件流，NIO.2</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211211125620004.png" alt="image-20211211125620004" style="zoom:67%;" />

<h3 id="3、节点流（或文件流）"><a href="#3、节点流（或文件流）" class="headerlink" title="3、节点流（或文件流）"></a>3、节点流（或文件流）</h3><h4 id="读入"><a href="#读入" class="headerlink" title="读入"></a>读入</h4><ol>
<li>read()的理解: 返回读入的一个字符。如果达到文件末尾，返回-1</li>
<li>异常的处理:为了保证流资源定可以执行关闭操作。需要使用try-catch-finally处理</li>
<li>读入的文件定要存在， 否则就会报FileNotFoundException</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    FileReader fR=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、实例化File类的对象，指明要操作的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        System.out.println(file.getAbsolutePath());</span><br><span class="line">        <span class="comment">//2、提供具体的流</span></span><br><span class="line">        fR = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="comment">//3、数据的读入</span></span><br><span class="line">        <span class="comment">//read()返回读入的一个字符，如果达到文件末尾返回-1</span></span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data=fR.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4、流的关闭</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fR!=<span class="literal">null</span>)fR.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写出"><a href="#写出" class="headerlink" title="写出"></a>写出</h4><p>1.创建流对象，建立数据存放文件，文件可以不存在，不会报异常，会自动创建此文件</p>
<ul>
<li><p>FileWriter(file,false)&#x2F; FileWriter(file)会对原有文件进行覆盖</p>
</li>
<li><p>FileWriter(file,true)会在原文件基础上追加</p>
</li>
</ul>
<p>2.调用流对象的写入方法，将数据写入流 </p>
<p>3.关闭流资源，并将流中的数据清空到文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    File file= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">    FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">    fw.write(<span class="string">&quot;I have a dream&quot;</span>);</span><br><span class="line">    fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt </p>
</li>
<li><p>字符流操作字符，只能操作普通文本文件。最常见的文本文 件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。</p>
</li>
</ul>
<h3 id="4、缓冲流"><a href="#4、缓冲流" class="headerlink" title="4、缓冲流"></a>4、缓冲流</h3><p>提供流的读取、写入的速度</p>
<p>提高读写速度的原因：提供了一个缓冲区</p>
<h3 id="5、转换流"><a href="#5、转换流" class="headerlink" title="5、转换流"></a>5、转换流</h3><p>将char转换为byte</p>
<p>InputStreamReader：实现将字节的输入流按指定字符集转换为字符的输入流，解码</p>
<p>OutputStreamWriter：实现将字符的输出流按指定字符集转换为字节的输出流，编码</p>
<h3 id="6、标准输入、输出流"><a href="#6、标准输入、输出流" class="headerlink" title="6、标准输入、输出流"></a>6、标准输入、输出流</h3><h3 id="7、打印流"><a href="#7、打印流" class="headerlink" title="7、打印流"></a>7、打印流</h3><h3 id="8、数据流"><a href="#8、数据流" class="headerlink" title="8、数据流"></a>8、数据流</h3><h3 id="9、对象流"><a href="#9、对象流" class="headerlink" title="9、对象流"></a>9、对象流</h3><p>重点：序列化机制</p>
<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制，内存—–&gt;文件</p>
<p>将内存中的java对象保存到磁盘中或者通过网络传输出去</p>
<p>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制，文件—–&gt;内存</p>
<p>将磁盘中的对象数据源读出</p>
<h4 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h4><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p>
<p>private static final long serialVersionUID; </p>
<p>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议显式声明。</p>
<h3 id="10、随机存取文件流"><a href="#10、随机存取文件流" class="headerlink" title="10、随机存取文件流"></a>10、随机存取文件流</h3><h3 id="11、NIO-2中Path、Paths、Files类的使用"><a href="#11、NIO-2中Path、Paths、Files类的使用" class="headerlink" title="11、NIO.2中Path、Paths、Files类的使用"></a>11、NIO.2中Path、Paths、Files类的使用</h3><h2 id="第14章-网络编程"><a href="#第14章-网络编程" class="headerlink" title="第14章 网络编程"></a>第14章 网络编程</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211211154252672.png" alt="image-20211211154252672"></p>
<h4 id="1、网络通信要素概述"><a href="#1、网络通信要素概述" class="headerlink" title="1、网络通信要素概述"></a>1、网络通信要素概述</h4><p>IP和端口号 </p>
<p>网络通信协议</p>
<h4 id="2、通信要素1：IP和端口号"><a href="#2、通信要素1：IP和端口号" class="headerlink" title="2、通信要素1：IP和端口号"></a>2、通信要素1：IP和端口号</h4><p>IP：唯一的标识 Internet 上的计算机（通信实体）</p>
<p>端口号：标识正在计算机上运行的进程（程序）</p>
<h4 id="3、通信要素2：网络协议"><a href="#3、通信要素2：网络协议" class="headerlink" title="3、通信要素2：网络协议"></a>3、通信要素2：网络协议</h4><p>TCP&#x2F;IP协议簇</p>
<h4 id="4、TCP网络编程"><a href="#4、TCP网络编程" class="headerlink" title="4、TCP网络编程"></a>4、TCP网络编程</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211211165932089.png" alt="image-20211211165932089"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> WindowTest;</span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.messaging.saaj.util.ByteOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现TCP的网络编程</span></span><br><span class="line"><span class="comment"> * 客户端发送信息给服务端，服务端将数据显示在控制台上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建Socket对象，指明服务器算的ip和端口号</span></span><br><span class="line">            InetAddress inet=InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2、获取一个输出流用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3、写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">&quot;你好&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4、资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span> (os!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        ServerSocket ss= <span class="literal">null</span>;</span><br><span class="line">        Socket socket= <span class="literal">null</span>;</span><br><span class="line">        InputStream is= <span class="literal">null</span>;</span><br><span class="line">        ByteOutputStream baos= <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2、调用accept方法表示接收来自客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">//3、获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            <span class="comment">//4、读取输入流中的数据</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5、资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">if</span>(socket!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">if</span>(ss!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>客户端： </p>
<ul>
<li><p>自定义 </p>
</li>
<li><p>浏览器</p>
</li>
</ul>
</li>
<li><p>服务端：</p>
<ul>
<li><p>自定义 </p>
</li>
<li><p>Tomcat服务器</p>
</li>
</ul>
</li>
</ul>
<h4 id="5、UDP网络编程"><a href="#5、UDP网络编程" class="headerlink" title="5、UDP网络编程"></a>5、UDP网络编程</h4><ol>
<li>UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li>
<li>DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和 接收方的连接。</li>
</ol>
<h4 id="6、URL编程"><a href="#6、URL编程" class="headerlink" title="6、URL编程"></a>6、URL编程</h4><p>URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址</p>
<p><strong>URI、URL和URN的区别</strong></p>
<ol>
<li>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</li>
<li>URL是uniform resource locator，统一资源定位符，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 </li>
<li>URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:<a href="mailto:&#106;&#97;&#x76;&#x61;&#45;&#x6e;&#x65;&#x74;&#64;&#x6a;&#97;&#x76;&#x61;&#x2e;&#x73;&#117;&#110;&#46;&#x63;&#111;&#x6d;">&#106;&#97;&#x76;&#x61;&#45;&#x6e;&#x65;&#x74;&#64;&#x6a;&#97;&#x76;&#x61;&#x2e;&#x73;&#117;&#110;&#46;&#x63;&#111;&#x6d;</a>。</li>
<li>URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。</li>
<li>URL 和URN都是一种URI。</li>
</ol>
<h2 id="第15章-JAVA反射机制"><a href="#第15章-JAVA反射机制" class="headerlink" title="第15章 JAVA反射机制"></a>第15章 JAVA反射机制</h2><h3 id="1、Java反射机制概述"><a href="#1、Java反射机制概述" class="headerlink" title="1、Java反射机制概述"></a>1、Java反射机制概述</h3><p>java.lang.Class:代表一个类 </p>
<p>java.lang.reflect.Method:代表类的方法</p>
<p>java.lang.reflect.Field:代表类的成员变量</p>
<p>java.lang.reflect.Constructor:代表类的构造器</p>
<h3 id="2、理解Class类并获取Class实例"><a href="#2、理解Class类并获取Class实例" class="headerlink" title="2、理解Class类并获取Class实例"></a>2、理解Class类并获取Class实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class clazz=Person.class;</span><br><span class="line">    <span class="comment">//1、通过反射，创建Person类的对象</span></span><br><span class="line">    Constructor con=clazz.getConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">    Object obj=con.newInstance(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    Person p=(Person) obj;</span><br><span class="line">    <span class="comment">//2、通过反射调用对象指定的属性、方法</span></span><br><span class="line">    <span class="comment">//调用属性</span></span><br><span class="line">    Field age=clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.set(p,<span class="number">10</span>);</span><br><span class="line">    System.out.println(p.toString());</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(p);</span><br><span class="line">    System.out.println(<span class="string">&quot;**************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过反射，可以调用Person类的私有结构</span></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">deC</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    deC.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) deC.newInstance(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    <span class="comment">//调用私有属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    name.set(p1,<span class="string">&quot;Micheal&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">    <span class="comment">//调用私有方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showNation</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">    showNation.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    showNation.invoke(p1,<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>直接通过new的方式或者反射的方式都可以调用公共的结构，开发中到底用哪个</p>
<p>直接new，什么时候用反射，反射的特征：动态性</p>
</li>
<li><p>反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术</p>
<p>不矛盾</p>
</li>
<li><p>java.lang.Class的理解</p>
<p>类的加载过程：程序经过javac.exe命令之后，会生成一个或多个字节码文件（.class）结尾，接着使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载，加载到内存中的类就称为运行时的类，也就是class的实例对应一个运行时类。加载到内存中的运行时类会缓存一定时间，在此时间之内，可以通过不同的方式来获取此运行时类。</p>
</li>
<li><p>获取Class实例的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//方式1：调用运行时类的属性.class</span></span><br><span class="line">    Class&lt;Person&gt; class1 = Person.class;</span><br><span class="line">    System.out.println(class1);</span><br><span class="line">    <span class="comment">//方式2：通过运行时类的对象</span></span><br><span class="line">    Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    Class class2=p1.getClass();</span><br><span class="line">    <span class="comment">//方式3：调用Class的静态方法：forName(String classPath)（用得最多）</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">class3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;WindowTest.Person&quot;</span>);</span><br><span class="line">    System.out.println(class3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3、类的加载与ClassLoader的理解"><a href="#3、类的加载与ClassLoader的理解" class="headerlink" title="3、类的加载与ClassLoader的理解"></a>3、类的加载与ClassLoader的理解</h3><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20211212162455735.png" alt="image-20211212162455735" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取配置文件（这个代码需要掌握）</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//配置文件默认识别为当前module的src下</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    pros.load(is);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user=&quot;</span>+user+<span class="string">&quot;password=&quot;</span>+password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、创建运行时类的对象"><a href="#4、创建运行时类的对象" class="headerlink" title="4、创建运行时类的对象"></a>4、创建运行时类的对象</h3><p>需要掌握</p>
<h3 id="5、获取运行时类的完整结构"><a href="#5、获取运行时类的完整结构" class="headerlink" title="5、获取运行时类的完整结构"></a>5、获取运行时类的完整结构</h3><h3 id="6、调用运行时类的指定结构"><a href="#6、调用运行时类的指定结构" class="headerlink" title="6、调用运行时类的指定结构"></a>6、调用运行时类的指定结构</h3><p>需要掌握</p>
<h3 id="7、反射的应用：动态代理"><a href="#7、反射的应用：动态代理" class="headerlink" title="7、反射的应用：动态代理"></a>7、反射的应用：动态代理</h3><p>想要实现动态代理，需要解决的问题？</p>
<ol>
<li>如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</li>
<li>当通过代理类的对象调用方法时，如何动态地调用被代理类中地同名方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> WindowTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewInstanceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();<span class="comment">//被代理类的对象</span></span><br><span class="line">        <span class="comment">//1、创建代理类的对象，传入参数：被代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//2、使用代理的对象调用被代理类的方法</span></span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;土豆&quot;</span>);</span><br><span class="line">        System.out.println(proxyInstance.getBelief());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类和被代理类需要实现同一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;共产主义&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法返回一个代理类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line">        handler.bind(obj);</span><br><span class="line">        <span class="comment">//参数分别为：被代理类的加载器，被代理类的接口（因为代理类和被代理类需要实现同一个接口），代理类到被代理类的一个方法转换的接口</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//被代理类，需要使用被代理类的对象赋值</span></span><br><span class="line">    <span class="comment">//方法功能：使用被代理类的对象赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当通过代理类的对象调用方法时，就会自动调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法的功能声明在invoke中</span></span><br><span class="line">    <span class="comment">//参数含义：代理类的对象，代理类的对象想要调用的方法，方法形参</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj, args);<span class="comment">//利用反射，调用方法的主体是被代理类的对象</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时整个代码里没有代理类，也叫不出代理类的类名，代理类是通过代理类工厂自动生成的，直接得到了代理类的对象</p>
<p>APO</p>
<h2 id="第16章JAVA8-的其他新特性"><a href="#第16章JAVA8-的其他新特性" class="headerlink" title="第16章JAVA8 的其他新特性"></a>第16章JAVA8 的其他新特性</h2><h3 id="之前提到的JAVA8新特性："><a href="#之前提到的JAVA8新特性：" class="headerlink" title="之前提到的JAVA8新特性："></a>之前提到的JAVA8新特性：</h3><h4 id="java8中接口新特性-1"><a href="#java8中接口新特性-1" class="headerlink" title="java8中接口新特性"></a>java8中接口新特性</h4><p>JDK8：除了全局常量和抽象方法，还可以定义静态方法和默认方法（default关键字修饰）</p>
<ol>
<li>接口中定义的静态方法只能通过接口来调用，接口.方法。</li>
<li>通过实现类的对象，可以调用接口中的默认方法，对象.方法。如果实现类重写了接口中的默认方法，调用时仍然调用的是重写以后的方法</li>
<li>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的方法，子类在没有重写此方法的情况下调用的是父类中的方法——类优先原则</li>
<li>如果实现类实现了多个接口，而这个多个接口中定义了同名同参数的默认方法，在实现类没有重写方法的情况下会报”接口冲突“错误，此时需要重写。</li>
<li>如何在子类（或者实现类）调用父类、接口中被重写的方法，接口.super.方法</li>
</ol>
<h4 id="JDK8中新日期时间API"><a href="#JDK8中新日期时间API" class="headerlink" title="JDK8中新日期时间API"></a>JDK8中新日期时间API</h4><h4 id="JDK8中注解的新特性"><a href="#JDK8中注解的新特性" class="headerlink" title="JDK8中注解的新特性"></a>JDK8中注解的新特性</h4><p>可重复注解、类型注解</p>
<h4 id="HashMap-JDK8-1"><a href="#HashMap-JDK8-1" class="headerlink" title="HashMap JDK8"></a>HashMap JDK8</h4><p>JAVA8之前是先建好数组，JAVA8之后是添加元素的时候才去造数组</p>
<h3 id="其他新特性"><a href="#其他新特性" class="headerlink" title="其他新特性"></a>其他新特性</h3><p>![](C:\Users\86187\Desktop\offer\尚硅谷\尚硅谷JAVA基础课件笔记源码资料\新建文件夹\1_课件\第2部分：Java高级编程\尚硅谷_宋红康_第16章_Java8的其它新特性\Java 8新特性 尚硅谷-宋红康.bmp)</p>
<h4 id="1、Lambda表达式"><a href="#1、Lambda表达式" class="headerlink" title="1、Lambda表达式"></a>1、Lambda表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1,o2) -&gt; Integer. compare(o1,o2);</span><br></pre></td></tr></table></figure>

<p>2.格式:</p>
<p>-&gt; :Lambda 操作符或 箭头操作符</p>
<p>-&gt;左边: lambda形参列表(其实就是接口中的抽象方法的形参列表)</p>
<p>-&gt;右边: Lambda体 (其实就是重写的抽象方法的方法体)</p>
<p>Lambda表达式的本质：作为函数式接口的实例</p>
<h4 id="2、函数式（Functional）接口"><a href="#2、函数式（Functional）接口" class="headerlink" title="2、函数式（Functional）接口"></a>2、函数式（Functional）接口</h4><h4 id="3、方法引用与构造器引用"><a href="#3、方法引用与构造器引用" class="headerlink" title="3、方法引用与构造器引用"></a>3、方法引用与构造器引用</h4><ol>
<li><p>方法引用本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例，自然方法引用也是函数时接口的实例</p>
</li>
<li><p>使用格式：类（或对象）：：方法名</p>
<p>​        对象：：非静态方法 P673</p>
<p>​        类：：静态方法 P674</p>
<p>​        类：：非静态方法 P675 </p>
</li>
<li><p>要求：接口中的抽象方法的形参列表和返回值类型与方法医用的方法形参列表和返回值类型相同</p>
</li>
</ol>
<h4 id="4、强大的Stream-API"><a href="#4、强大的Stream-API" class="headerlink" title="4、强大的Stream API"></a>4、强大的Stream API</h4><p>1、Sream关注的是对数据的运算，与CPU打交道</p>
<p>​    集合关注的是数据的存储，与内存打交道</p>
<p>2、操作流程</p>
<p>1- 创建 Stream 一个数据源（如：集合、数组），获取一个流 </p>
<p>2- 中间操作 一个中间操作链，对数据源的数据进行处理 </p>
<p>3- 终止操作(终端操作) 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</p>
<p>3、说明</p>
<p>①Stream 自己不会存储元素。 </p>
<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
<p>4、一个中间操作链，对数据源的数据进行处理</p>
<p>一旦执行终止操作，就执行中间操作链并产生结果，之后不会再被使用</p>
<h4 id="5、Optional类"><a href="#5、Optional类" class="headerlink" title="5、Optional类"></a>5、Optional类</h4><h2 id="第17章-JAVA9-amp-JAVA10-amp-JAVA11新特性"><a href="#第17章-JAVA9-amp-JAVA10-amp-JAVA11新特性" class="headerlink" title="第17章 JAVA9 &amp; JAVA10 &amp; JAVA11新特性"></a>第17章 JAVA9 &amp; JAVA10 &amp; JAVA11新特性</h2>

<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>READ NEXT</span></section><section class="body fs14"><a id="next" href="/2022/03/27/hello-world/">Hello World<span class="note">Older</span></a><div class="line"></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p>
<p>This site was deployed by <a href="https://c508.github.io/">@mikang</a> using <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.6.1" title="v1.6.1">Stellar</a>.</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.6.1';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
